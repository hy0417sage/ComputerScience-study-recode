# 00. JAVA 
👩🏻‍💻 [블로그](https://lumiere.tistory.com/category/언어%20%26%20프레임워크/00.%20Java)

## 01. 객체, 클래스, 인스턴스란?
- 객체란 **물리적으로 존재**하거나 **추상적으로 생각**할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말합니다.
- 클래스란 객체들을 소프트웨어 내에서 구현하기 위해 만든 설계도입니다.
- 인스턴스란 현실의 객체를 소프트웨어 내에서 구현한 실체로, 클래스를 통해 생성된 객체 하나하나를 클래스의 인스턴스라고 부릅니다. 

## 🌟 02. hashcode(), == 와 equals의 차이점 / 동등성과 동일성
- equals와 hashcode()는 Object 클래스에 정의되어 있어 자바의 모든 객체는 Object클래스에 정의된 hashcode 함수를 상속받고 있습니다.
- 하지만 이 둘은 두 객체의 어떤 부분을 확인하는 메소드인지에서 차이가 생깁니다.
- equals()는 두 객체의 내용이 같은지 검사하기 위해 사용되는 메소드 입니다. 즉, 동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로 두 객체가 가리키는 곳이 동일한 메모리 주소일 경우에만 동일한 객체가 됩니다.
- hashCode는 두 객체가 같은 객체인지 확인하는 Method입니다.
HashTable과 같은 자료구조를 사용할때 데이터가 저장되는 위치를 결정하기 위해 사용됩니다.
- 결국 동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 합니다. 
- 그렇기 때문에 equals()메소드를 오버라이드 한다면, hashcode()메소드도 오버라이드 되어야 합니다.
- Java 프로그램을 실행하는 동안 equals에 사용된 정보가 수정되지 않았다면, hashCode는 항상 동일한 정수값을 반환해야 한다. (Java의 프로그램을 실행할 때 마다 달라지는 것은 상관이 없다.)
두 객체가 equals()에 의해 동일하다면, 두 객체의 hashCode() 값도 일치해야 한다.
두 객체가 equals()에 의해 동일하지 않다면, 두 객체의 hashCode() 값은 일치하지 않아도 된다.

## 03. 메소드와 함수의 차이점 : java(메소드형)와 kotlin(함수형)
- 함수는 여러 문장들이 하나의 기능을 구현하도록 구성한 것이라고 할 수 있다. 
- 그 함수 중에서 클래스 내부에 정의한 함수를 메소드라고 한다. 
- 또한 메소드는 객체의 속성을 다루기 위한 행위를 정의한 것이라는 의미도 포함하고 있다.
- 즉, 독립적으로 존재하는 함수이냐, 클래스 내부에 종속되어 있느냐의 구분으로 함수와 메소드를 구분할 수 있다.

#### 함수형 프로그래밍의 장점
- 높은 수준의 추상화를 제공한다.
- 함수 단위의 코드 재사용이 수월하다.
- 불변성을 지향하기 때문에 프로그램의 동작을 예측하기 쉬워진다.

## 04. Java 빌드
- 빌드(Build)는 소스코드 파일을 실행가능한 소프트웨어 산출물로 만드는 일련의 과정을 말한다. 

## 05. 연산자란 무엇일까요?
- 주어진 식을 계산하여 결과를 얻어내는 과정을 연산이라고 하며, 연산을 수행하는 기호를 연산자라고 한다.
#### 연산자 우선순위
- 최우선연산자 ( . [] () )
- 단항연산자 ( ++ -- ! ~ + - : 부정, bit변환>부호>증감)
- 산술연산자 ( * / % + - shift) < 시프트연산자 ( >>,<<,>>> ) >
- 비교연산자 ( > < >= <= == != )
- 비트연산자 ( & | ~ )
- 논리연산자 (&& || !)
- 삼항연산자 (조건식) ? :
- 대입연산자 = *= /= %= += -=

## 05-2. 기본형과 참조형 변수
- 기본형(primitive type) 변수
  - boolean, char, byte, short, int, long, float, double
  - 실제 연산에 사용되는 것은 모두 기본형 변수이다.
- 참조형(reference type) 변수
  - 기본형 8가지를 제외한 나머지 타입
  - 참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조형 변수의 타입이 된다. 
  - 따라서 새로운 클래스를 작성하는 것은 새로운 참조형 변수를 추가한다고 봐도 무방하다.

## 05-3. 참조(reference)
- 참조와 참조형 변수는 다른 개념이다.
- 참조는 참조형 변수가 아닌 참조값(reference value, 해쉬코드)이다.
- 예를 들자면 A x = new A();의 경우 new가 반환한 참조(reference)는 new A();의 반환값이고, 참조형 변수(reference variable)는 x이다.

## 06. 형 변환이 뭔가요?
- 형 변환(Type Conversion)이란 데이터의 타입을 변경하는 것이다.
#### 묵시적 형변환(Implicit Type Conversion)이란?
- 묵시적 형변환이란 컴파일러에 의해 자동으로 형변환이 이루어지는 것을 말한다. 
- 예를 들어 int a 와 float b를 더할 때 int a는 자동으로 float형으로 형변환이 이루어진다. 
- 묵시적 형변환은 표현 범위가 좁은 데이터 타입에서 넓은 데이터 타입으로의 변환만 허용된다. 
- 예를 들어 int 형은 double 형으로 형변환 될 수 있지만 double 형은 int형이 될 수 없다. 
#### 명시적 형변환(Explicit Type Conversion)이란?
- 명시적 형변환이란 사용자가 직접 데이터의 타입을 변경하는 것이다. 
- 사용자가 double 형을 int 형으로 형변환 할 수 있다. 
- 묵시적 형변환과 다르게 표현 범위가 넓은 데이터 타입에서 좁은 데이터 타입으로의 변환이 허용된다. 하지만 데이터의 값이 손실될 수 있다. 
- double 값이 1.3일 때 int형으로의 변환이 이루어지면 값은 1이 된다. 소수부가 손실된 것이다.
#### 안전한 형변환을 하는 방법은 뭘까요?(답. instanceOf 활용)
- 참조변수 형 변환 가능 여부 확인에 사용
- 변환할 때 형 변환 해도 되는지 확인 해야 한다. -> instanceOf 사용!!

### 06-2. 참조 변수 간 형변환
- 참조 변수 간의 형변환은 상속 관계에 있는 타입에 한해서 가능하다. 즉, 자식 타입 <-> 브모 타입 간 형변환이 가능한데, 두 경우 역시 표현 문법이 다르다.
- 자식 타입 -> 부모 타입 (형변환 생략됨)
-  타입 -> 자식 타입 (형변환 생략 못함)

## 07. Object란 뭘까요?
- 자바는 객체지향 프로그래밍(OOP; Object Oriented Programming) 언어 중 대표적인 언어이다. 객체지향 프로그래밍이라는 단어에서 객체란 무엇일까?
- 객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신과 다른 것을 식별가능한 것을 말한다. 
- 예를 들어 물리적으로 존재하는 학생, 회원 등과 추상적인 생산, 주문, 배송 등이 모두 객체가 될 수 있다.
- 객체는 속성과 동작으로 구성되어 있다. 사람을 예로 들어보면 사람의 속성으로는 이름, 나이 등이 있다. 그리고 동작으로는 달리다, 공부하다 등이 있다.
- 자바에서는 이러한 객체의 속성을 필드(field), 동작을 메소드(method)라고 한다.

## 08. Object 클래스란? (java.lang.Object 클래스)
- 자바에서 Object 클래스는 모든 클래스의 부모 클래스가 되는 클래스이다. (조상 클래스)
- 자바의 모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 된다.
- 따라서 Object 클래스의 모든 메소드를 바로 사용할 수 있다.
- 자바의 모든 클래스는 별도로 extends 키워드를 사용하여 Object 클래스의 상속을 명시하지 않아도 Object 클래스의 모든 멤버를 자유롭게 사용할 수 있다.
- 자바의 모든 객체에서 toString()이나 clone()과 같은 메소드를 바로 사용할 수 있는 이유가 해당 메소드들이 Object 클래스의 메소드이기 때문이다.

## 10. 싱글톤이 뭘까요?
- 싱글톤 패턴은 객체의 인스턴스를 한개만 생성되게 하는 패턴이다.
- 프로그램 내에서 하나로 공유를 해야하는 객체가 존재할 때 해당 객체를 싱글톤으로 구현하여 모든 유저 또는 프로그램들이 해당 객체를 공유하며 사용하도록 할 때 사용된다.
  - 프로그램 내에서 하나의 객체만 존재해야 할 때 사용한다.
  - 프로그램 내에서 여러 부분에서 해당 객체를 공유하여 사용해야할 때 사용한다.
  
## 11. static이 뭘까요?
- static은 변수나 메소드에 키워드로 사용되며 static 키워드를 사용한 변수는 클래스가 메모리에 올라갈 때 자동으로 생성이 된다. 
- 즉, 인스턴스(객체) 생성 없이 바로 사용가능 하다. 
- 객체를 생성하지 않아도 되니까 편리하고 속도도 빠르다.
- 자주 변하지 않는 일정한 값이나 설정 정보같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해서 접근하는 것이 비용도 줄이고 효율을 높일 수있다. 
- 인스턴스 생성 없이 바로 사용가능 하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리 할 때 이용한다.

## 12. package란?
- 자바 패키지란 클래스들의 모음집이다.
- 패키지를 통해서 라이브러리끼리 구분이 가능하다.
- 패키지를 사용하는 이유는 클래스명의 고유성을 보장하기 위함이다.
- 때로는 서로 다른 용도의 라이브러리를 도입할 때 이름이 충돌하는 클래스들이 있을 수 있는데 이럴 때 패키지 기능을 사용하여 클래스의 이름이 충돌하는 것을 방지할 수 있다.

## 13. 접근 제어자는 무엇일까요?
- 접근 제어자는 말 그대로 "변수와 메서드에 접근을 어디까지 허용하게 할 것인지 권한을 설정" 할 때 사용된다.
1. public : 접근 제어자가 public으로 설정되었다면, 변수와 메서드는 패키지에 상관 없이 모든 클래스에서 접근이 가능하다.
2. protected : 접근 제어자가 protected로 설정 되었다면 "동일한 패키지내의 클래스" 또는 "해당 클래스를 상속 받은 외부 패키지의 클래스"까지 접근이 가능하다.
3. default : 접근 제어자를 별도로 설정하지 않으면 "기본 변수, 메서드가 되며 해당 패키지 내에서만 접근"이 가능하다.
4. private : 접근 제어자가 private으로 설정되었다면, "해당 변수와 메서드는 해당 클래스에서만 접근"이 가능하다.

## 14. 상속이란? (inheritance)
- 상속이란 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미한다.
  - 이러한 상속은 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다.
- 상속을 이용하면 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있다.
- 기존에 정의되어 있던 클래스를 부모 클래스(parent class) 또는 상위 클래스(super class), 기초 클래스(base class)라고도 한다.
- 상속을 통해 새롭게 작성되는 클래스를 자식 클래스(child class) 또는 하위 클래스(sub class), 파생 클래스(derived class)라고도 한다.
#### 상속의 장점
1. 기존에 작성된 클래스를 재활용할 수 있다.
2. 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 된다.
3. 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련한다.
~~~java
class 자식클래스이름 extend 부모클래스이름 { ... }
~~~

## 15. 상속의 생성자
- 부모 클래스의 생성자는 상속되지 않고, 자식 클래스로 인스턴스를 생성할 때 자동적으로 부모의 기본 생성자가 호출된다. 
  - 부모 생성자의 기본 생성자 자동적으로 호출된다. 이때 부모 클래스의 생성자가 먼저 호출되고 뒤이어 자식 클래스의 생성자가 호출된다.
- 부모 생성자가 매개 변수를 가지고 있다면 자식 클래스를 인스턴스화 할 때 자동으로 호출되지 않는다.
  - 자식 클래스로 인스턴스를 생성할 때 자동적으로 부모 클래스의 기본 생성자가 호출된다, 하지만 매개변수를 갖는 부모 클래스의 생성자는 자동으로 호출되지 않는다.
- 따라서 자식 생성자에서 명시적으로 부모 생성자를 호출해야 한다.
  - 이때 사용되는 키워드가 super();이다. super()를 사용할 때는 자식 생성자의 첫 줄에 위치해야 한다.

## 16. 오버라이딩(overriding)이란?
- 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하여 사용하는 것이다. 
- 자식 클래스에서 부모의 메소드를 수정해야 할 때 사용된다. 일반 클래스의 상속 관계에서는 많이 사용되지는 않고 추상 클래스나 인터페이스에서 필수적으로 사용되는 개념이다.
- 자식 클래스에서 부모 클래스의 메소드와 동일한 시그니쳐(메소드 이름, 리턴 타입, 매개변수의 개수/자료형/순서)를 적용하여야 한다.
- 오버라이딩 결과 부모 메소드는 은닉되고 자식 클래스에서 재정의된 메소드만 기본적으로 호출된다. 필요시 super. 으로 부모 메소드를 호출할 수 있다.

## 17. API (Application Programming Interface)
- API는 자바 언어를 사용하면서 누군가 코딩을 쉽게 할 수 있도록 만들어 놓은 것, 누군가가 만들어 놓은 API를 사용하여 만들려고 했던 프로그램의 완성도가 높아지고 낮은 시간을 투자하여 추가적인 기능을 탑제할 수 있게 해주는 것이 API이다.
- System.out.println() 이것도 다른 개발자들이 만들어 놓은것을 사용하는 것이다.

## 18. 쓰레드란? (thread)
- 스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미한다.
- 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다.
- 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 한다.

## 19. 프로세스(process)란?
- 프로세스(process)란 단순히 실행 중인 프로그램(program)이라고 할 수 있다.
- 즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말한다.
- 이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성된다.

## 20. Object 클래스 메소드들
- **객체를 처리**하기 위한 메소드
  - proctected Object **clone()**	객체의 복사본을 만들어 리턴한다.
  - public boolean **equals(Object obj)**	현재 객체와 매개 변수로 넘겨 받은 객체가 같은지 확인하다. 같으면 true를 다르면 false를 리턴한다.
  - protected void **finalize()**	현재 객체가 더 이상 쓸모가 없어졌을 때 가비지 컬렉터에 의해서 이 메소드가 호출된다.
  - public Class<?> **getClass()**	현재 객체의 Class 클래스의 객체를 리턴한다.
  - public int **hashCode()** 객체의 고유값을 나타낸다. 객체에 대한 해시코드값을 리턴한다. 해시코드란 16진수 객체 메모리의 주소를 말한다.
  - public String **toString()** 객체를 문자열로 표현하는 값을 리턴한다.
- **쓰레드 처리**를 위한 메소드
  - public void **notify()**이 객체의 모니터에 대기하고 있는 단일 스레드를 깨운다.
  - public void **notifyAll()**	이 객체의 모니터에 대기하고 있는 모든 스레드를 깨운다.
  - public void **wait()**	다른 스레드가 현재 객체에 대한 notify() 메소드나 notifyAll() 메소드를 호출할 때까지 현재 스레드가 대가하고 있도록 한다.
  - public void **wait(long timeout)**	wait() 메소드와 동일한 기능을 제공하며, 매개 변수에 지정한 시간만큼만 대기한다. 즉, 매개변수 시간을 넘어 섰을 때에는 현재 스레드는 다시 깨어난다. 시간은 밀리초 단위다.
  - public void **wait(long timeout, int nanos)**	wait()메소드와 동일한 기능을 제공한다. 이 메소드는 밀리초 + 나노초(1/1,000,000,000)만큼만 대기한다.

## 21. Object 클래스에서 가장 많이 쓰이는 toString() 메소드
- toString은 말 그대로 객체의 정보를 String(문자열)형으로 형변환 해준다.
- Object클래스를 상속받은 클래스들은 toString()을 오버라이딩(재정의)하여 사용할 수 있다.
- 해당 클래스가 어떤 객체인지 쉽게 나타낼 수 있는 중요한 메소드다.

## 22. 자바 인터페이스란?(Interface)
- 극단적으로 동일한 목적하에 동일한 기능을 수행하게끔 강제하는 것, 극단적으로 동일한 목적 하에 동일한 기능을 보장하게 하기 위함.
- 어떻게? 자바의 다형성을 이용하여 개발코드 수정을 줄이고 유지보수성을 높인다.
- 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위해 인터페이스를 사용한다.

## 23. 다형성이란? (polymorphism)
- 다형성(polymorphism)이란 부모-자식 상속 관계에 있는 클래스에서 상위 클래스가 동일한 메시지로 하위 클래스들을 서로 다르게 동작시키는 객체 지향 원리이다.
- 다형성을 활용하면 부모 클래스가 자식 클래스의 동작 방식을 알수 없어도 오버라이딩을 통해 자식 클래스를 접근할 수 있다.
- 부모가 자식이 어떤 일을 하는 지 몰라도 자식 멤버 함수를 호출시킬 수 있는 이유는 동적 바인딩 때문이다. 
- 동적바인딩이란, 메서드가 실행 시점에서 성격이 결정되는 바인딩으로 프로그램의 컴파일 시점에 부모 클래스는 자신의 멤버 함수밖에 접근할 수 없으나, 실행 시점에 동적 바인딩이 일어나 부모클래스가 자식 클래스의 멤버함수를 접근하여 실행할 수 있다.

## 24. 추상 클래스 (abstract)
- 실체클래스의 공통적인 부분(변수,메서드)를 추출해서 선언한 클래스
- 추상클래스는 아직은 실체성이 없고 구체적이지 않기 때문에 객체를 생성할 수 없다.
- 추상클래스와 실체클래스는 상속관계이다.
- 공통된 필드와 메서드를 통일할 목적으로 사용된다.
- 실체클래스 구현시 시간이 절약된다.
- 소스 수정시 다른 소스의 영향도를 적게 가져가면서 변화에는 유연하게 만들기 위해 추상클래스를 사용하기도 한다. 
- 규격에 맞게 소스가 구현되어 있기 때문에 해당 규격에 대한 구현부만 수정하면 손 쉽게 수정이 가능하기 때문이다.

## 25. SOLID : 객체 지향 설계란?
- 객체 지향을 올바르게 설계할 수 있도록 도와주는 원칙
- SOLID 원칙들은 결국 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion - Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것이다.
- 소프트웨어는 재 사용이 많아지고, 수정이 최소화 되기 때문에 결국 유지 보수가 용이해진다. 
- SRP (Single Responsibility Principle) 단일 책임 원칙 : 클래스의 역할과 책임을 너무 많이 주지 마라.
- OCP (Open Closed Principle) 개방 폐쇄 원칙 : 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
- LSP (Liskov Substitution Principle) 리스코프 치환 원칙 : 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙 : 상황과 관련 있는 메서드만 제공해라.
- DIP (Dependency Inversion Principle) 의존 역전 원칙 : 자신보다 변하기 쉬운 것에 의존하지 마라.
**설계를 잘 해야 프로그램 유지 보수 측면에서 굉장히 용이하고 개발 시간과 비용을 절감할 수 있다.**

## 26. final
- 내 자식들에게 하나도 물려주지 않을테다!
- java 프로그래밍 언어에서 final 키워드는 여러 컨텍스트에서 단 한 번만 할당할 수있는 엔티티를 정의하는 데 사용된다.
- final 키워드는 변수(variable), 메서드(method), 또는 클래스(class)에 사용될 수 있다. 
- 이 final 키워드는 어떤 곳에 사용되냐에 따라 다른 의미를 가진다. 
- 하지만 final 키워드를 붙이면 무언가를 제한한다는 의미를 가지는 것은 공통적이 성격이다.

## 27. enum 클래스 (열거체)
- 클래스처럼 보이게 하는 상수, 서로 관련있는 상수들끼리 모아 상수들을 정의하는것, enum 클래스 형을 기반으로 한 클래스형 선언
- enum 클래스의 부모는 java.lang.Enum
- 열거체를 비교할 때 실제 값뿐만 아니라 타입까지도 체크한다.
- 열거체의 상숫값이 재정의되더라도 다시 컴파일할 필요가 없다.

## 28. 인터페이스와 추상 클래스, 클래스의 차이점 [참고](https://brunch.co.kr/@kd4/6)
- 추상 클래스와 인터페이스는 상속받는 클래스 혹은 구현하는 인터패이스 안에 있는 추상 메소드를 구현하도록 강제한다.

## 29. 예외 (try catch)
- 자바에서의 예외는 "우리가 예상한, 혹은 예상하지도 못한 일이 발생하는 것을 미리 예견하고 안전장치를 하는 것"을 말한다.
- try 문안의 수행할 문장들에서 예외가 발생하지 않는다면 catch문 다음의 문장들은 수행이 되지 않는다. 하지만 try 문안의 문장을 수행하는 도중에 예외가 발생하면 예외에 해당되는 catch문이 수행된다.
~~~ java
int value;
try {
    value = 4 / 0;
} catch(ArithmeticException e) {
    value = -1;  // 예외가 발생하여 이 문장이 수행된다.
}
~~~

## 30. finally
- 프로그램 수행 도중 예외가 발생하면 프로그램이 중지되거나 예외 처리에 의해 catch 구문이 실행된다. 
- 하지만 어떤 예외가 발생하더라도 반드시 실행되어야 하는 부분이 있어야 한다면 finally 구문 사용한다.
- finally 구문은 try 문장 수행 중 예외발생 여부에 상관없이 무조건 실행된다.

## 31. 예외의 종류 3가지
- checked excepion
- runtime excepion 혹은 unchecked excepion : (런타임 예외) 예외가 발생할 것을 미리 감지하지 못했을 때 발생한다. 해당하는 모든 예외들은 RuntimeException을 확장한 예외들이다.
- error : 자바 프로그램 밖에서 발생한 예외를 말한다. (자바 프로그램이 제대로 동작하기 못하는 경우)

## 32. 예외 클래스 (Throwable 클래스)
- 모든 예외의 할아버지는 java.lang.Throwable 클래스이다. (최상위 클래스)
- 모든 Exception과 Error클래스는 Trowable 클래스를 상속받아 처리하도록 되어있다.
- Exception이나 Error를 처리할 때 Trowable로 처리해도 무관하다.

## 33. 예외 던지기 (throws)
- "예외를 뒤로 미루기"라고도 한다.
- 예외가 발생했을 때 예외를 일으키는 메서드를 호출한 메서드로 예외를 넘기고 책임을 전가하는 방법
- 예외를 넘겨받은 메소드는 try - catch 문을 이용하여 예외를 처리하여야 한다. 
- 즉, 예외를 넘겨받는 메서드에게 예외 처리를 강제(또는 유도)한다. throws를 이용하여 예외를 던지고 처리하는 기본적인 방법은 다음과 같다.
~~~java
리턴타입 메소드1(){
  try{
      메소드명2();
  }catch(예외클래스){
      예외처리 코드
  }
}

리턴타입 메소드2([매개변수...]) throws 예외클래스1..{..}
~~~

## 34. String 클래스
- String 클래스는 참조형 객체 클래스이며 불변 객체(immutable object)로 한번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수 없다.
  - 불변 객체로 동일한 객체가 공유되면서 사용된다.
- 자바에서는 문자열을 위한 String이라는 클래스를 별도로 제공한다. java.lang 패키지에 포함되어 제공된다.
- String 클래스에는 문자열과 관련된 작업을 할 때 유용하게 사용할 수 있는 다양한 메소드가 포함되어 있다.
  - 자바에서 덧셈(+) 연산자를 이용하여 문자열 결합을 수행하면, 기존 문자열의 내용이 변경되는 것이 아니라 내용이 합쳐진 새로운 String 인스턴스가 생성되는 것.
- 스트링은 원시 타입처럼 보여서 원시타입으로 착각 할 수 있다. 하지만 스트링은 원시타입이 아니며 참조형 객체 클래스이다. 
- 스트링 클래스는 2가지의 선언 방법 (둘다 print 해보면 값은 똑같지만 둘은 분명한 차이가 있다.)
  - 리터럴
  ~~~java
  String text = "text";
  ~~~
  - new 를 사용한 선언
  ~~~java
  String text = new String("text");
  ~~~
- 리터럴로 선언된 String 클래스는 선언시 객체가 String constant pool 에 저장이되는 반면 new 는 Heap 영역에 저장된다.
- String 객체를 비교시 == 보다는 equals 를 많이 사용한다.

## 35. String 클래스에서 절 때 사용해서는 안되는 메소드 intern()
- 성능에 저하가 생긴다.
- 만약 새로운 문자열을 쉴새 없이 만드는 프로그램에서 intern() 메소드를 사용하여 억지로 문자열 풀에 값을 할당하도록 만들면, 저장되는 영역은 한계가 있기 떄문에 그 영역에 대해서 변도로 메모리를 청소하는 단계를 거치게 된다. 따라서 작은 연산 하나를 빠르게 하기 위해서 전체 자바 시스템의 성능에 악영향을 주게 된다.

## 36. StringBuffer와 StringBuilder [참고](https://12bme.tistory.com/42)
- String은 불변 객체(immutable object)다. (한번 만들어지면 더 이상 그 값을 바꿀 수 없다.)
- 문자열을 더하면 새로운 String 객체가 생성되고, 기존 객체는 버려진다.
- 그러므로 계속 하나의 String을 만들어 계속 더하는 작업을 한다면, 계속 쓰레기를 만들게 된다.
- 불변의 String의 단점을 보완하는 클래스에는 StringBuffer와 StringBuilder가 있다. (가변 mutable)
~~~
String은 짧은 문자열을 더할 경우 사용한다.
StringBuffer는 스레드에 안전한 프로그램이 필요할 때나, 개발 중인 시스템의 부분이 스레드에 안전한지 모를 경우 사용하면 좋다.
StringBuilder는 스레드에 안전한지 여부가 전혀 관계 없는 프로그램을 개발할 때 사용하면 좋다.
~~~
- StringBuffer, StringBuilder의 차이점
  - 동기화의 유무로써 StringBuffer는 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전하다는 점(thread-safe)을 가지고 있다. 
    - String도 불변성을 가지기 때문에 마찬가지로 멀티쓰레드 환경에서의 안정성(thread-safe)을 가지고 있다.
  - 반대로 StringBuilder는 동기화를 지원하지 않기때문에 멀티쓰레드 환경에서 사용하는 것은 적합하지 않지만 동기화를 고려하지 않는 만큼 단일쓰레드에서의 성능은 StringBuffer 보다 뛰어나다.

## 37. Nested 클래스란?
- 클래스 안에 클래스가 들어가는 것

#### Nested 클래스를 사용하는 이유는?
- 코드를 간단하게 표현하기 위함
- 자바 기반의 UI를 처리할 때 사용자의 입력이나, 외부의 이벤트에 대한 처리를 하는 곳에서 많이 사용된다.
- 이러한 부분에서 Nested 클래스가 없으면 코드가 매우 복잡해 진다.

#### Nested 클래스는 그럼 어떤 상황일 때 사용할까?
- 한 곳에서만 사용되는 클래스를 논리적으로 묶어서 처리할 필요가 있을 때 (Static Nested 클래스를 사용하는 이유)
- 캡슐화가 필요할 때 (내부 구현을 감추고 싶을 때, 내부 클래스를 사용하는 이유)
- 소스의 가독성과 유지보수성을 높이고 싶을 때 (내부 클래스를 사용하는 이유)

#### Static nested 클래스와 내부 클래스의 차이
- 내부 클래스는 외부클래스의 어떤 변수도 접근할 수 있고, 심지어 private로 선언한 변수 까지도 접근 가능하다.
- Static nested 클래스는 그렇게 까지 사용하는 것은 불가능하다. 말그대로 static하기 때문이다.
- 객체를 생성하는 방법의 차이도 있다.
- 내부 클래스의 객체를 생성하기 전에는 먼저 내부 클래스를 감싸고 있는 클래스 객체를 만들어야 한다. 
 
## 38. 내부클래스와 익명 클래스
1. 내부 클래스 
- GUI 관련 프로그램을 개발할 때 가장 많이 사용한다.
- GUI에서 내부 클래스들이 많이 사용되는 부분은 리스너라는것을 처리할 때이다.

#### * 리스너
- 사용자가 버튼을 클릭하거나, 키보드를 입력할 때에는 모두 이벤트라는 것이 발생하게 된다.
- 어떤 버튼이 눌렸을 때 해야하는 작업을 정의하기 위해서 내부 클래스를 만들어 사용하게 된다.

2. 익명 클래스
- 하나의 애플리케이션에서 어떤 버튼이 눌렀을 때 수행해야 하는(리스너) 작업이 대부분 상이하기 때문에 익명 클래스를 만들어 사용한다.
- 클래스를 만들면 만들수록 메모리는 많이 필요해지고, 애플리케이션을 시작할 때 더 많은 시간이 소요된다.
- 그래서 익명 클래스를 만듬으로 프로그램에서 일시적으로 한번만 사용되고 버려지는 객체를 만들어 사용한다.

**익명 클래스와 내부 클래스 모두 다른 클래스에서 재사용할 일이 없을 때 만들어야 한다.**

## 39. Nested 클래스의 특징
- 참조 가능한 변수들을 고려해야 한다.
- 만약 클래스가 static으로 선언되어있다면 부모 클래스에 static하지 않은 변수를 참조할 수는 없다.

## 40. 자바 어노테이션(Java Annotation)
- 에노테이션은 주석이라는 의미를 가진다.
- 자바 소스 코드에 사이에 @ 기호를 앞에 붙여서 사용하는데,  JDK 1.5 버전 이상에서 사용 가능하다.
- 어노테이션의 용도
  - 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공 | 컴파일러에게 정보를 알려줌
  - 소프트웨어 개발툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공 | 컴파일할 때와 설치 시의 작업을 지정
  - 실행시(런타임시)특정 기능을 실행하도록 정보를 제공 | 실행할 때 변도의 처리가 필요할 때

### 1. 어노테이션 종류 : 자바 코드에 적용되는 내장 어노테이션
- **@Override**
  - 선언한 메서드가 오버라이드 되었다는 것을 나타낸다.
  - 만약 상위(부모) 클래스(또는 인터페이스)에서 해당 메서드를 찾을 수 없다면 컴파일 에러를 발생 시킨다.
- **@Deprecated**
  - 해당 메서드가 더 이상 사용되지 않음을 표시한다.
  - 만약 사용할 경우 컴파일 경고를 발생 시킨다.
- **@SuppressWarnings**
  - 선언한 곳의 컴파일 경고를 무시하도록 한다.

### 2. 타 어노테이션에 적용되는 어노테이션 (메타 애터네이션)
- @Target
  - 어노테이션을 어떤것에 적용할 지를 선언할 때 사용한다.
- @Retention
  - 얼마나 오래 어노테이션 정보가 유지되는지를 선언한다.
  - 자바 컴파일러가 어노테이션을 다루는 방법을 기술하며, 특정 시점까지 영향을 미치는지를 결정한다.
- @Documented
  - 해당 어노테이션에 대한 정보가 Javadocs(API) 문서에 포함된다는 것을 선언한다.
- @Inherited
  - 어노테이션의 상속을 가능하게 한다.
  - 모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능하다는 것을 선언한다.

### 어노테이션도 상속이 안된다.
- 자바의 상속은 많은 이점을 제공하지만 enum클래스가 상속을 지원하지 않듯이 어노테이션을 선언할 때에도 미이 만들어 놓은 어노테이션을 확장하는것이 불가능 한다.
- 즉, extends 라는 예약어를 사용할 수가 없다. 코드가 반복되는 문제가 발생한다고 해도 어쩔 수 없이 재사용은 불가능 하다.

***
***

19장 키워드

## 41. 자바 언어의 특징
1. 단순하고, 객체지향이며, 친숙 해야한다.
2. 견고하며, 보안상 안전하다.
3. 아키텍처에 중립적이어야 하며 포터블 해야 한다.
4. 자바는 높은 성능을 제공해야 한다.
5. 자바는 인터프리터 언어이며, 쓰레드를 제공하고, 동적인 언어이다.


## 42. JIT 컴파일러 (just - in - time)
<자바가 실행되는 순서>
자바 소스 코드 -> 자바 컴파일러 -> 컴파일 된 바이트 코드 -> JVM -> 기계 코드 -> 하드위어 및 OS
:JVM -> 기계코드 로 변환되는 부분을 JIT에서 수행


## 43. 자바를 배우면 꼭 알아야 하는 용어
- JVM : 자바 가상 머신 : 작성한 자바 프로그램이 실행되는 프로세스를 말합니다. </br>
java라는 명령어를 통해서 어플리케이션을 수행되면, 이 JVM위에서 애플리케이션이 동작합니다. </br>
이 JVM에서 작성한 프로그램을 찾고 실행하는 일련의 작업이 실행된다.
- GC : 가비지 컬렉터 : JVM 내에서 메모리 관리를 해주는 것, 사용 않고 남아있는 객체들을 알아서 청소해 준다.

## 44. Java.lang 패키지
- Java.lang안에 있는 패키지는 import를 안해도 사용할 수 있다.
- Java.lang에서 제공하는 인터페이스, 클래스, 예외 클래스 등은 이처럼 분류할 수 있다.
    - 언어 관련 기본
    - 문자열 관련
    - 기본 자료형 및 숫자 관련
    - 쓰레드 관련
    - 예외 관련
    - 런타임 관련

### 자바랭의 숫자처리 클래스
기본 자료형은 자바의 스텍 영역에 저장되어 관리한다. “Java stack primitive types”
- Byte
- Short
- Integer
- Long
- Float
- Double
기본 자료형에서 첫 문자만 대문자로 바꿨울 경우 감싼 클래스라고 불리며 모두 Number하는 추상클래스를 확장(extend) 한다.
겉으로 보기에는 참조 자료형이지만, 기자바 컴파일러에서 자동으로 형 변환을 해주기 때문에 기본 자료형처럼 사용할 수 있다.
그리고 boolean 클래스를 포함해 parse타입이름() 메소드와 valueOf()라는 메소드를 제공한다.그리고 이 두가지 메소드는 static메소드 이다.
따라서 객체를 생성하지 할 필요없이 사용 가능하다.


둘다 숫자 타입으로 변환한다는 공통점이 있지만
parse타입이름() 메소드는 기본 자료형을 리턴하고, valueof()메소드는 참조 자료형을 리턴한다.

~~~java
Integer refInt1 = Integer.valueOf(value1);
Integer refInt2 = Integer.valueOf(value2);
System.out.printIn(refInt1+refInt2+”7”);
//87
~~~

매개변수를 참조 자료형으로만 받는 베소드를 처리하기 위해서 이러한 숫자를 처리하는 참조 자료형을 만든것
- MIN_VALUE, MAX_VALUE
: 기본 자료형을 참조 자료형으로 만든 클래스들은 Boolean클래스를 제외하고 MIN_MAX VALU라는 상수를 가지고 있다.

### 자바랭의 각종 정보를 확인하기 위한 System 클래스

## 21장 제네릭
#### DTO (Data Transfer Object)
- Private
- Getter
- Setter
- Serializable
#### [DTO 클래스]
~~~java
Package d.generic;

Import java.io.Serializable;

Public class CastingDTO implements Serializable{
	private Object object;
	public void setObject(Object object){
		this.object = object;
	}
	public void getObject(Object object){
		return object;
	}
}
~~~
CastingDTO 클래스에서 getObject를 호출할 때 리턴값으로 넘어오는 타입은 Object이기 때문에 각각의 타입으로 형 변환을 해주어야 한다.

## 45. 제네릭이란?
- 위와 같은 타입 형 변환에서 발생할 수 있는 문제점을 ‘사전’에 없애기 위해서 만들어진 것이 제네릭 이다. *사전 : 컴파일 시 점검
~~~java
Package d.generic;

Import java.io.Serializable;

Public class CastingGenericDTO<T> implements Serializable{
	private Object object;
	public void setObject(T object){
		this.object = object;
	}
	public T getObject(){
		return object;
	}
}
~~~
꺽쇠<> 부분이 생겼다. <br>
꺽쇠 안의 값은 가상의 타입 이름으로 아무 이름으로 지정해도 컴파일 하는데 상관이 없다. (클래스 이름과 명명 규칙을 동일하게 지정하는 것이 좋다.)<br>
그럼 CastingDTO 와 CastingGenericDTO 의 객체 선언 차이를 보자<br>
~~~ java
// CastingDTO
CastingDTO dto1 = new CastingDTO();
dto.setObject(new String());
String temp1 = (String) dto.getObject(); //String으로 형 변환을 해준다.

// CastingGenericDTO
CastingGenericDTO<String> dto = new CastingGenericDTO<String>();
dto2.setObject(new String());
String temp2 = dto2.getObject(); 
// 객체에 선언되어 있는 dto2의 제네릭 타입은 String이기 때문에 형 변환을 해줄 필요가 없음으로 ‘실행’시에 다른 타입으로 잘못 형 변환을 하여 예외가 발생하는 일은 없다.
~~~

## 46. 제네릭 타입 이름 정하기 : 자바에서 정의한 기본 규칙
- E : 앨리먼트, 자바 컬렉션 에서 사용됨
- K : 키
- N : 숫자
- T : 타입
- V : 값
- S, U, V : 두 번째, 세 번째, 네번째에 선언된 타입

## 47. 제네릭의 ‘?’ 란 (Wildcard 타입)
~~~java
public void stringMethod(WildcardGeneric<String> c){
} 
~~~
String이 아닌 다른 타입으로 선언된 WildcardGeneric 객체를 받으려면 
 ~~~java
public void stringMethod(WildcardGeneric<?> c){
} 
~~~
이와 같이 선언하면 된다. <br>
하지만 메소드 내부에서는 해당 타입을 잘 모르기 때문에 Object로 값을 받아야 한다.<br>
만약 넘어오는 타입이 2,3 가지로 정해져 있다면, instanceof예약어를 사용하여 해당 타입을 확인하면 된다.<br>
wildcard는 메소드의 매개 변수로만 사용하는 것이 좋다.

## <> 안에는 wildcard로 사용하는 타입을 제한할 수 있다.
- ‘?’대신 ‘? extend 타입’ 으로 선택할 수 있다.
~~~java
Public void boundedWildcardMethod(WildcardGeneric<? Extends Car> c){
	Car value = c.getWildcard();
	System.out.println(value);
}
~~~
이 경우 반드시 Car과 관련되어 있는 상속한 클래스가 넘어와야 한다.<br>
‘? extends 타입’ 과 같은 것을 Bounded Wildcard라고 부른다. 매개 변수로 넘어오는 제네릭 타입의 경계를 지정하는 데 사용한다는 의미로 해석하면 된다.

## 48. 메소드를 제네릭하게 선언하기
wildcard로 메소드를 선언할 때 매개 변수로 사용된 객체에 값을 추가할 수 없다는 단점이 있다.<br>
값을 추가하기 위해선,
~~~java
public <T> void genericMethod(wildcardGeneric<T> c, T addValue){
	//TODO
} 
~~~
메소드 선언시 리턴 타입 앞에 제네릭한 타입을 선언해 주고, 그 타입을 매개 변수에서 사용하면 컴파일 할때 문제 없고 값도 할당 할 수 있다.

## 49. 자바의 컬렉션
- 목록성 데이터를 처리하는 자료구조
- 자바에서는 set, list, queue 가 collection 이라는 인터페이스를 구현하고 있다.

## 50. List 목록
- 배열처럼 순서를 가지고 있는 인터페이스 이다.
- List 인터페이스를 구현한 클래스들은 매우 많다.
- ArrayList, Vector, Stack, LinkedList를 많이 사용한다.

## 51. ArrayList와 Vector
- 사용법과 기능 둘다 거의 비슷하다. 이 두 클래스는 '확장 가능한 배열'이라고 생각하면 된다.
- 차이점 : ArrayList의 객체는 여러명이 달려들어 값을 변경하려고 하면 문제가 발생할 수 있고, Vector는 그렇지 않다. (Vector는 (Tread safe) 하다.)
- 대부분의 메소드가 ArrayList와 동일하고, 보통 Vector 보다 ArrayList를 선호한다.

## 52. Stack
- 마지막 데이터를 가장 처음에 꺼내는 기능을 구현하려고 할때 필요한 클래스 이다.
- vector 클래스를 확장하여 만들었다.
- Last in Frist out
- 메소드가 호출된 순서를 기억하는 장소를 말한다.

## 53. LinkedList
- '목록'과 '큐'에 속하는 클래스 이다.

## 54. ArrayList

## 55. set이란?
순서에 상관없이, 어떤 데이터가 존재하는지 확인하기 위한 용도로 많이 사용한다.
1. HashSet : 순서가 전혀 필요 없는 데이터를 해시 테이블에 저장한다. Set중에 가장 성능이 좋다.
2. TreeSet : 저장된 데이터의 값에 따라 정렬이 되는 Set이다. Red-black이라는 트리 타입으로 값이 저장 되며, HashSet 보다 약간 성능이 느리다.
3. LinkedHashSet : 연결된 목록 타입으로 구현된 해시 테이블에 데이터를 저장한다. 저장된 순서에 따라서 값이 저장된다. 대신 성능이 셋중에서 가장 나쁘다.
**이러한 성능의 차이가 발생하는 이유는 정렬 때문이다.**

## 56. HashSet
- set은 순서가 없다. 따라서, ㅅㄴ서가 매개 변수로 넘어가는 메소드나, 수행 결과가 데이터의 위치와 관련된 메소드는 Set 인터페이스에서는 필요가 없다. 그러므로, get()이나 indexOf()와 같은 메소드 들은 Set에 존재하지 않는다.
- Hash클래스의 4가지 생ㅇ성자 중 자주나오는 로드 팩터(load factor)는 무엇일까?

## 57. 로드 팩터
- 데이터의 개수/저장공간 을 의미한다.
- 만약 데이터의 개수가 증가하여 로드 팩터보다 커지면, 저장 공간의 크기는 증가되고 해시 재 정리 작업을 해야만 한다.

## 58. 프로세스란?
- 실행 중인 프로그램이다.

## 59. 쓰레드란?
- 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다.
- java 명령어를 사용하여 클래스를 실행 시키는 순간 자바 프로세스가 시작되고, main()메소드가 수행 되면서 하나의 쓰레드가 시작된다.

## 60. 

	
	


