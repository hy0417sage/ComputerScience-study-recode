# 7장. 웹을 안전하게 지켜주는 HTTPS

## HTTP의 약점
1. 평문이기 때문에 도청 가능 - TCP/IP는 도청 가능한 네트워크
2. 통신 상대를 확인하지 않기 때문에 위장 가능 
3. 완전성을 증명할 수 없기 때문에 변조 가능

### SSL
- SSL은 암호화 뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공한다.

### 1. 평문이기 때문에 도청 가능 해결 방안 - 도청 피하기
- 통신 암호화 : SSL이나 TLS이라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화 할 수 있다.
- 콘텐츠 암호화 : HTTP 메세지에 포함되는 콘텐츠만 암호화 하는 것

### 2. 통신 상대를 확인하지 않기 때문에 위장 가능 해결 방안
- 상대를 확인하는 증명서 발급 : SSL로 상대를 확인할 수 있다. 이 증명서는 신뢰할 수 있는 제 3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재한다는 사실을 증명한다.
    - 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 개인 정보 누설 등의 위험성이 줄어들게 된다.

### 3. 완전성을 증명할 수 없기 때문에 변조 가능 해결 방안 - 수신할 내용이 다를지도 모른다.
- 중간자 공격 : 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 할지 모름
- 변조를 방지하려면 : MD5이나 SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 있다.

## 결국 HTTPS = HTTP + 암호회 + 인증 + 완정성 보호
- HTTP의 문제를 해결하기 위해 HTTP에 암호화나 인증 등의 구조를 더함
- HTTPS는 SSL의 껍질을 덮어쓴 HTTP이다.
- HTTP 통신을 하는 소켓 부분을 SSL이나 TLS이라는 프로토콜로 대체한다.
    - 그럼 HTTP는 SSL와 통신하고 SSL이 TCP와 통신하게 된다.

# SSL

## SSL에서는 공개키 암호화 방식을 사용한다. - 공통키 암호화의 딜레마
- 공통키 암호화의 딜레마 - 암호화도 복호화도 같은 키를 사용한다. - 키를 넣으면 누구라도 암호를 해독할 수 있다.

### 두 개의 키를 사용하는 공개 키 암호 
- 서로 다른 두 개의 키 페어를 사용한다.
    - 공개키 암호를 사용한 암호화는 암호를 보내는 측이 **상대의 공개키를 사용해 암호화**를 한다.
    - 암호화된 정보를 받아들인 상대는 **자신의 비밀키를 사용해 복호화**를 한다.

### 모든 통신에 공개키 암호를 사용하는 것은 비효율 적이다.
- 공개키 암호는 공통키 암호보다 처리가 느리기 때문에, 모든 통신에 공개키 암호를 사용하는 것은 비 효율적이다.

### 공개키가 정확한지 아닌지를 증명 - CA
- 서버가 발행한 공개키인지 증명 - 도중에 공격자가 공개키를 바꿔치기 했을지도 모름
- 이 문제를 해결하는 데는 인증기관(CA) 와 그 기관이 발행하는 공개키 증명서가 이용되고 있다.

### 인증기관 CA 이용 방법
1. 서버의 운영자가 인증 기관에 공개키를 제출
2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만든다.
3. 공개키 인증서에 서명이 끝난 공개키를 담는다.
4. 서버는 이 인증 기관에 의해 작성된 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신한다.
- 증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해서 서버의 공개키를 인증한 것이 진짜 인증기관이라는 것과 서버의 공개키가 신뢰할 수 있다는 것을 알 수 있다.

### SSL과 TLS
- HTTPS에서는 SSL과 TLS라는 두개의 프로토콜이 사용되고 있다.
- SSL 통신이 느린(지연)이유 
    1. 통신 속도가 떨어짐
    2. CPU나 메모리 등의 리소스를 다량으로 소비함

### 왜 항상 HTTPS를 사용하지 않는가?
- 평문 통신에 비해 암호화 통신은 CPU나 메모리 등 리소스가 많이 필요하기 때문이다.
- 그렇기 때문에 민감한 정볼ㄹ 포함하지 않은 통신에서는 HTTP를 사용한다.

# 8장. 누가 액세스 하고 있는지를 확인하는 인증
- 패스워드
- 전자 인증서 
- IC 카드 등

## HTTP에서 사용하는 인증 방법
- BASIC 인증 : 웹 서버와 대응하고 있는 클라이언트 사이에서 이루어지는 인증
- DIGEST 인증(챌린지 리스폰스 방식) : 최초에 상대방에게 인증 요구를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산
- SSL 클라이언트 인증 : 유저 ID와 패스워드 정보가 도난당했을 때 제 3자가 위장한다. -> SSL 클라이언트 인증이 이 대책 중 하나.
    - 2-factor 인증에서 사용한다. : 패스워드라는 한 개의 요소만이 아닌 이용자가 가진 다른 정보를 병용해서 인증을 하는 방법
- 폼베이스 인증 : 클라이언트가 서버 상의 웹 어플리케이션 자격 정보를 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식
    - 인증의 대부분은 폼베이스 인증이다.

### 폼베이스 인증
- 폼베이스 인증은 인증 자체는 서버 측의 웹 애플리케이션 등에 의해서 클라이언트가 송신해온 유저 ID와 패스워드가 사전에 등록하고 있는 것과 일치하는지 어떤지를 검증
- 그러나!! **HTTP는 stateless 프로토콜이다!**
- 때문에 방금 전에 인증을 성공핸던 유저라는 상태를 프로토콜 레벨에서는 유지할 수 없다. 즉, 상태 관리가 안되기 때문에 다음에 그 유저가 액세스 했다고 하더라도 다른 유저와 구별하지 못함. 그래서 세션 관리와 쿠키를 사용하여 HTTP에 없는 상태 관리 기능을 보충한다.

# 9장. HTTP에 기능을 추가한 프로토콜
1. SPDY : 스피디, HTTP의 병목 현상을 해소하고 웹 페이지 로딩 시간을 50% 단축한다는 목표를 세우고 개발

### HTTP 병목 현상이란?
- 시스템의 전체 성능이나 용량이 하나 혹은 소수개의 구성 요소나 자원에 의해 제한받는 현상을 말한다.
- HTTP에서는 서버의 정보가 갱신되었는지 아닌지를 알기 위해서 클라이언트가 항상 서버측에 확인하러 가야 한다. -> 서버상의 정보가 갱신되지 않은 경우, 불필요한 통신 발생
1. ajax에 의한 해결 방법 : 웹 페이지의 일부분만 고쳐쓸 수있는 비동기 통신 방법
    - 페이지의 일부분만 갱신되기 때문에 리스폰스로 전송되는 데이터 양은 줄어든다는 장점이 있다.
2. Comet에 의한 해결 방법 : 서버측의 콘텐츠에 갱신이 있을 경우, 클라이언트로부터 리퀘스트를 기다리지 않고 클라이언트에 보내기 위한 방법.
    - 커넥션을 유지하여 리스폰스 보류, 커넥션을 유지하는 동안 리소스를 소비함
3. SPDY의 목표 : 근본적인 개선을 위해 프로토콜 래벨에서의 개선이 필요하다.

### SPDY 설계와 기능
- TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 들어감으로써 데이터의 흐름을 제어하지만, HTTP의 커넥션은 확립되어있다.
- HTTP의 GET이나 POST와 같은 메소드나 쿠키, HTTP 메시지 등을 그대로 사용할 수 있다.

## 브라우저에서 양방향 통신을 하는 웹소켓
- 웹소켓은 새로운 프로토콜과 API에 의해 병목현상을 문제를 해결하기 위한 기술로서 개발되었다.

### WebSocket 프로토콜 - 양방향 통신이 가능하다.
- 웹 서버와 클라이언트가 한번 접속을 확립하면 그 뒤의 통신을 모두 전용 프로토콜로 하는 방식
- HTTP에 의한 접속의 출발점이 클라이언트에 있다는 것에는 변함이 없지만, 한번 접속이 확립되면 websocket 을 사용하여 서버와 클라이언트 어느 쪽에서도 송신을 할 수 있게 된다.

### WebSocket 기능
1. 서버 푸시 기능 - 서버는 클라이언트의 리퀘스트를 기다리지 않고 데이터를 보낼 수 있다.
2. 통신량의 삭감 - 접속을 한번 확립하면 접속을 유지하려고 한다.
    - 통신을 하기 위해 핸드쉐이크 절차를 밟을 필요가 있다.


# 10장. 웹 콘텐츠에서 사용하는 기술
- 웹 페이지 대부분은 HTML로 되어 있다. - 웹 상에서 하이퍼텍스트를 보내기 위해서 개발된 언어. / HTML로 쓰여진 문서를 브라우저가 해석해서 렌더링 처리한 결과가 웹 페이지에 표시된다.
- DOM - HTML을 조작하기 쉽게 해줌. - HTML 문서와 XML 문서를 위한 API
- GCI - 웹서버와 프로그램을 연계함 - 웹 서버가 클라이언트에서 받은 리퀘스트를 프로그램에 전달하기 위한 구조 - 동적으로 콘텐츠를 생성할 수 있다.
- 서블릿 - 동적 컨텐츠를 생성하기 위한 프로그램 - CGI는 리퀘스트마다 프로그램을 가동하기 때문에 대량으로 액세스가 있을 때 웹 서버에 부하가 걸리게 되지만, 서블릿에서는 웹 서버와 같은 프로세스 속에서 동작하기 떄문에 비교적 부하를 적게하여 동작시킬 수 있다.
- 갱신정보를 송신하는 RSS/Atom

# 11장 웹 공격의 기술
- 공격 대상은 HTTP를 이용한 서버와 클라이언트 그리고 서버 상에서 동작하는 웹 어플리케이션 등의 리소스이다. - HTTP 자체가 공격 대상이 되지는 않음

### 웹어플리케이션 공격 패턴
## 능동적 공격 - SQL 인젝션, OS 커맨드
- 공격자가 직접 웹 애플리케이션에 엑세스해서 공격 코드를 보내는 타입

### SQL 인젝션
- 부정한 SQL을 실행하는 SQL 인젝션
- 웹 애플리케이션을 이용하고 있는 데이터베이스에 SQL을 부정하게 실행하는 공격이다.
    - SQL 문장의 구분을 파괴한다.

### OS 커맨드 인젝션
- 웹 애플리케이션을 경유하여 OS 명령을 부정하게 실행하는 공격이다.
    - 예시. 송신 버튼 -> 공격자 입력값에 ; 붙이기 커맨드 실행된 후 일단락 -> 계정정보가 포함된 파일이 헤커 이메일로 전송

## 수동적 공격 - XSS, CSRF
- 함정을 이용해서 유저에게 공격 코드를 실행시키는 공격
- 수동적 공격을 이용하면 인트라넷 같은 인터넷에서 직접 액세스할 수 없는 네트워크를 공격할 수 있습니다.
- 많은 인트라넷에서는 인터넷 상의 웹 사이트에 액세스 하거나 인터넷에서 전송되어 온 메일을 읽을 수도 있기 때문에 공격자는 함정으로 유도하여 인트라넷을 공격할 수 있게 됩니다.

### XSS 크로스 사이트 스크립팅
- 취약성이 있는 웹 사이트를 방문한 사용자의 브라우저에서 부정한 HTML 태그나 JavaScript 등을 동작시키는 공격
- 폼에 함정을 설치하는 것 외에 유저의 쿠키를 빼앗을 수도공격자가 어떤 벙법으 있다.

### HTTP 헤더 인젝션
- 공격자가 리스폰스 헤더 필드에 개행 문자 등을 삽입함으로 임의의 리스폰드 헤더 필드나 바디를 추가하는 수동적인 공격
- 

### 메일 헤더 인젝션
- 웹 애플리케이션의 메일 송신 기능에 공격자가 임의의 To 및 Subject 사이트등의 메일 헤더를 부정하게 추가하는 공격이다.
- 취약성이 있는 웹 사이트를 이용해서 스팸 메일이나 바이러스 메일 등을 임의의 주소에 송신할 수 있다.

### 디렉토리 접근 공격
- 디렉토리 파일에 대해 부정하게 디렉토리 패스를 가로질러 액세스 하는 공격
- 패스 트레버셩이라고도 함

### 리모트 파일 인클루젼
- 스크립트 일부를 다른 파일에서 읽어올 때 공격자가 지정한 외부 서버의 URL을 파일에서 읽게 함으로써 임으의 스크립트를 동작시키는 공격

## 웹 서버의 설정이나 설계 미비로 인한 취약성
### 강제 브라우징
- 웹 서버의 공개 디렉토리에 있는 파일 중에서 공개 의도가 없는 파일이 열람되게 되는 취약성
### 부적절한 에러 메세지 처리 
- 공격자에게 유익한 정보가 웹 애플리케이션의 에러 메세지에 포함된단ㄴ 취약성이다.
### 오픈 리다이렉트
- 지정한 임의의 URL로 리다이렉트 하는 기능
- 리다이렉트되는 곳의 URL에 악의가 있는 웹 사이트가 지정된 경우 유저가 그 웹 사이트로 유도되는 취약성과 연결된다.

## 세션관리 미비
- 세션 하이젝 - 공격자가 어떤 방법으로 유저의 세선 ID를 입수해서 악용하는 것, 유저로 위장하는 공격
- 세션 픽세이션 - 공격자가 지정한 유저 ID를 강제적으로 사용하게 함
- 크로스사이트 리퀘스트 포저리 CSRF - 인증된 유저가 의도하지 않은 개인 정보나 설정 정보 등을 공격자가 설치해둔 함정에 의해 어떤 상태를 갱신하는 처리를 강제로 실행시키는 공격으로 수동적 이다.