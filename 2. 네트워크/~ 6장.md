# 3장 HTTP 정보는 GTTP 메세지에 있다.
- HTTP에서 교환하는 정보를 HTTP 메세지라고 한다.

## 인코딩으로 전송효울을 높이다.
- 다량의 액세스 효율 좋게 처리 가능
- CPU 등의 리소스는 보다 많이 소비하게 됨
- 콘텐츠 코딩 - 엔티티 정보를 유지한 채로 압축한다.
- 청크 전송 코딩 - 엔티티 바디를 분할해 사이즈가 큰 코딩을 전송한다.
- 멀티파트 - 여러 데이터를 보냄 (텍슽, 영상, 이미지)

### 레인지 리퀘스트 - 범위를 지정하여 리퀘스틑 하는 것
- 다운로드 중 커넥션이 끊어지게 되면 처음부터 다시 다운로드 -> 리줌 기능 필요 : 이전에 다운로드 한 곳에서 부터 다시 다운로드 재개

### 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
- 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조

### 메시지 바디와 엔티티 바디의 차이
- 메시지 - HTTP 통신의 기본 단위로 옥텟 시퀀스로 구성되고 통신을 통해서 전송된다.
- 엔티티 - 리퀘스트랑 리스폰스의 페이로드로 전송되는 정보로 엔티티 헤더와 엔티티 바디로 구성된다.

# 4장 : 상태코드
### 2XX 성공 : 리퀘스트가 정상 처리됨
- 200 OK 정상 처리
- 204 리퀘스트 성공, but 돌려줄 ㄹ리소스 없음
- 206 일부만 리퀘스트 성공

### 3xx 리다이렉트 : 리퀘스트가 정상적으로 처리를 종료하기 위해 브라우저 측에서 특별한 처리를 수행
- 301 

### 4xx : 클라이언트 에러
- 400 : 잘못된 리퀘스트
- 401 : 유저 인증 실패
- 403 리소스 액세스 거부
- 404 리소스 서버에 없음

### 5xx 서버 에러


# 5장
- HTTP와 연계하는 웹서버

## 1대로 도메인을 가능하게 하는 가상 호스트
- 같은 IP 주소에서 다른 호스트명과 도메인 명을 가진 여러개의 웹 사이트가 실행되고 있는 가상 호스트의 시스템이 있기 때문에,
- HTTP 리퀘스트를 보내는 경우에는 호스트 명과 도메인 명을 완전하게 포함된 URI를 지정하거나, 반드시 Host 필드에서 지정해야한다.

## 통신을 중계하는 프로그램 : 프록시, 게이트웨이, 터널
- 프록시 - 서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램으로, 클라이언트로 부터의 리퀘스트를 서버에 전송하고, 서버로부터 리스폰스를 클라이언트에 전송한다.
- 게이트웨이 - 다른 서버를 중계하는 서버로, 클라이언트로부터 수신한 리퀘스트를 리소스를 보유한 서버인 것 처럼 수신한다. 경우에 따라서 클라이언트는 상대가 게이트웨이란ㄴ 것을 알지 못하는 경우도 있다.
- 터널 - 서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계 프로그램
    - 리소스 본체를 가진 서버를 오리진 서버라고 부른다.

### 프록시
- 프록시 서버를 사용하는 이유는 
1. 나중에 설명할 캐시를 사용해서 **네트워크 대역등을 효율적으로 사용**하는 것과 
2. 조직 내에 특정 웹 사이트에 대한 액세스 제한, 액세스 로그를 획득 하려는 정책을 철저하게 지키려는 목적으로 사용

#### 1. 캐싱 프록시
- 프록시로 리스폰스를 중계하는 때에 프록시 서버 상에 리소스 캐시를 보존해 두는 프록시

#### 2. 투명 프록시
- 프록시로 리퀘스트와 리스폰스를 중계를 할 때 메시지 변경을 하지 않는 타입의 프록시를 투명 프로시라고 한다.
- 반대로 메시지에 변경을 가하는 타입을 비투과 프록시라고 한다.

### 게이트 웨이 - 신용카드 시스템
- 프록시와 유사, 게이트웨이의 경우 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버
- 클라이언트와 게이트웨이 사이를 암호화 하는 등으로 안전하게 접속함으로 **통신의 안전성을 높이**는 역할을 한다.

### 터널 
- **요구에 따라서 다른 서버와의 통신 경로를 확립**한다.
- 이때 클라이언트는 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신을 하기 위해 사용한다.
- 터널 자체는 리퀘스트를 해석하려고 하지 않는다. 결국 리퀘스트를 그대로 다음 서버에 중계한다. 양쪽 끝의 접속이 끝어질 떄 종료한다.

## 리소스를 보관하는 캐시
- 캐시는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본을 가리킨다.
- 캐시를 사용하면 리소스를 가진 서버에의 액세스를 줄이는 것이 가능하다 -> 통신량과 통신 시간을 절약할 수 있다.
- 장점 : 같은 데이터를 몇번이고 오리진 서버에 전송할 필요가 없다.

### 캐시에 유혀기간이 있는 이유는?
- 캐시 서버는 갱신ㄴ되기 전의 낡은 리소스를 그대로 보냄

### 클라이언트 측에도 캐시가 있다.
- 캐시 서버와 마찬가지로 리소스가 오래된 것으로 판단되는 경우 오리진 서버에 리소스의 유효성을 확인하러 가거나 새로운 리소스를 다시 획득하러 감

# 6장 HTTP 헤더
- 메세지 헤더에는 클라이언트나 서버가 이퀘스트 리스폰스를 처리하기 위한 정보가 들어있다.

### 리퀘스트 HTTP 메세지
1. 리퀘스트 라인 - 메소드, URI, HTTP 버전
2. 리퀘스트 헤더 필드
3. 일반 헤더 필드
4. 엔티티 헤더 필드

### 리스폰스의 HTTP 메세지
1. 상태 라인 - HTTP 버전, 상태 코드
2. 리스폰스 헤더 필드
3. 일반 헤더 필드
4. 엔티티 헤더 필드

## HTTP 헤더필드는 중요한 종보를 전달한다.
- 부가적으로 중요한 정보를 전달하는 역할을 담당
~~~
헤더 필드 명 : 필드 값
~~~

## HTTP 헤더 필드 - 4종류
1. 일반적 헤더 필드 - 리스폰드, 리퀘스트 메시지 둘다 해당
2. 리퀘스트 헤더 필드 - 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로 리퀘스트의 부가적 정보와 클라이언트 정보, 리스폰스의 콘텐츠에 관한 우선순위 등을 부여한다.
3. 리스폰드 헤더 필드 - 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가한다.
4. 엔티티 헤더필드 - 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더러 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가한다.

## HTTP 헤더 필드는 캐시와 비캐시 프록시의 동적을 정의하기 위해 두 가지 카테고리로 분류
1. End-to-end 헤더 - 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. 캐시에서 구축된 리스폰스 중 보존 되어애 하고, 다시 전송되지 않으면 안됨
2. Hop-by-hop 헤더 - 한번 전송에 대해서만 유효, 캐시와 프록시에 의해서 전송되지 않는 것도 있다.

## Connection 헤더필드
1. 프록시에 더 이상 전송하지 않는 헤더 필드를 지정
2. 지속적 접속 관리

## Via 
- 클라이언트와 서버간의 리퀘스트 혹은 리스폰스 메세지의 경로를 알기 위해 사용됨