# 코틀린 기본 정리

## 변수와 상수
- val (variable) : 상수 값 선언
- var : 변수 값 선언

### 기본 자료형
- 기본 자료형 Primitive data type : 순수하게 값을 저장하는 자료형
- 참조 자료형 Reference data type : 객체를 만들고 객체의 참조값을 저장한다.
- **코틀린의 자료형은 모두 참조 자료형!!** 모든 자료형이 객체 형태이다. 

#### 코틀린 정수 자료형 : Byte, Short, Int, Long
- Byte (1 Byte)
- Short (2 Byte)
- Int (3 Byte)
- Long (8 Byte)

#### 코틀린의 실수 자료형 : Double, Float
- Double (8 Byte)
- Float (4 Byte) 
- 자료형을 명시하지 않으면 Double형
- Float 형으로 지정하고 싶다면 값뒤에 f

#### 논리 자료형 : Char, String
- Char = 'H' //문자 하나
- String = 'Hi Hello' // 문자열

#### 배열 자료형 : arrayOf()
- val stringArray = arrayOf("apple", "banana", "grape")
 
#### 명시적 형 변환 : toString(), toDouble()

## 코틀린 제어문
- 직관젹이고 간결한 제어문을 제공한다.
- for, while, if, when

### 범위 클래스 
- : IntRange
- : CharRange
- val charRange : CharRange = 'a'..'e'

### for 문
- in 연산자와 함께 사용할 수 있음
- for(i in 1..5 step 2) //중위 연산자 step 사용
- for(i in 1...5 downTo 1)
- for((index, name) in student.withIndex())

### while 문
- 주어진 조건이 참일 때 계속 반복하는 제어문
- while(num < 5)

### if 문
- if(num > 8)

### when 문
- 코틀린은 switch 문이 없음. when 문이 있음.
- when(essayScore) {
    in 0..40 -> "D"
    else -> "A"
} 


## 컬렉션 : List, Set, Map

### List : listOf(), mutableListOf()
- 순서가 있는 자료구조
- 읽기, 쓰기 전용 리스트 만들 수 있음
~~~kotlin
val numImmutableList = listOf(1, 2, 3)
numImmutableList[0] = 1 //오류 발생
~~~
~~~kotlin
val numMutableList = mutableListOf(1, 2, 3)
numMutableList[0] = 100
~~~

### Set : setOf(), mutableSettOf
- 순서가 없는 자료구조
- 중족되지 않는 요소들로 만들어 짐
~~~kotlin
val immutable = setOf(1, 1, 2, 2, 3, 3, 3, 4) // 1, 2, 3, 4
~~~

### Map : mapOf(), mutableMapOf()
- 키와 값을 짝지어 저장하는 자료구조
- 키는 중복되지 않아야 함

## 함수 vs 메서드
- 함수 : 어떠한 기능을 수행하는 코드 형식
- 메서드 : 클래스 안에 선언된 함수

## 클래스의 생성자
- 객체를 생성할 때 항상 실행되는 특수한 함수로 **객체 초기화가 목적**
- 주생성자(primary constructor)와 보조 생성자(secondary constructor)가 있음

### 주 생성자
- 클래스 이름 옆에 괄호로 둘러쌓인 코드를 주 생성자라고 함 (constructer 생략 가능)
- class Person(name : String){}

### 보조 생성자
- 클래스 바디 내부에서 constructor 키워드를 이용해 만들며, 객체 생성시 실행할 코드를 작성해 넣을 수 있다.
- 주 생성자가 존재할 때 반드시 this 키워드를 통해 주 생성자를 호출해야 한다.

### 초기화 블록
- 객체 생성시 필요한 작업을 하는 것이 초기화 블록이다.
- init{} 안의 코드들은 객체 생성 시 가장 먼저 실행되고 주 생성자의 매개변수를 사용할 수 있다.
- 주로 주 생성자와 같이 쓰인다.

## 클래스의 상속
- 코틀린에서 상속을 받으려면 부모 클래스에서 open 키워드를 추가해야 한다.
- 메서드도 자식 클래스에서 오버라이드 하려면 부모 클래스의 메서드에 open 키워드를 추가해야함

## 접근 제한자
- 누구에게 클래스의 메서드와 변수를 공개할 것인가?
### public 
- 코틀린의 기본 접근 제한자. 어디서나 접근 가능
### internal 
- 같은 모듈 내에서 접근 가능. 
- 안드로이드 개발 시에는 한 프로젝트 안에 있으면 같은 모듈이라고 보면 됨
- 만약 한 프로젝트에 여러 모듈을 만든다면 이는 모듈간의 접근이 제한됨
### protected
- 자식 클래스에서는 접근할 수 있음
### private
- 해당 클래스 내부에서만 접근할 수 있음

## companion 키워드
- 자바에서는 static 키워드를 이용하면 정의된 변수나 메서드들은 객체를 만들지 않고도 접근이 가능
- 코틀린에서는 companion 키워드가 그 역할

## 추상 클래스
- 추상 클래스란 그 자체로는 객체를 만들 수 없는 클래스로 일반적으로 추상 메서드가 포함된 클래스를 말한다.
- 추상 메서드란 아직 구현되지 않고 추상적으로만 존재하는 메서드를 말한다.
- 추상 클래스와 추상 메서드 앞에 abstract 키워드를 붙인다.
- 상속받은 자식 클래스에 특정 메소드를 강제 구현하고 싶을 때 사용
- 추상 클래스 자체로는 직접 객체를 만들 수 없고 자식 클래스에서 추상 메서드를 구현한 다음, 자식 클래스를 생성하면 된다.

## 데이터 클래스
- 코틀린의 데이터 클래스는 특정한 메서드 실행 보다는 데이터 전달에 목적이 있다.
- 코틀린은 데이터 전달용 객체를 간편하게 생성하도록 data class라는 키워드를 제공한다.

## 인터페이스
- 클래스들이 같은 기능을 수행하게끔 강제한다.
- 예를 들면 자동차 인터페이스 경우, 최소한 가고, 멈추는 기능을 추상 메서드로 만들어야 한다.
- 추상 메서드임을 선언하는 키워드 abstract 는 추상 클래스에서는 필요하나 인터페이스에선 생략할 수 있다.

## 디폴트 메서드
- 코틀린도 자바처럼 인터페이스에서 기본적으로 구현하는 메소드를 제공할 수 있다.
- 해당 인터페이스들을 구현하는 클래스들은 디폴트 메서드 만큼은 오버라이드 하지 않아도 된다. (필요시 해도 됨)

## Null 처리하기
- 자바에서는 객체가 반환하는 함수가 반환할 객체가 없을 때 null을 반환한다.
- 이 방식은 null 체크가 필요하다
- 안그러면 NPE을 만나게 된다. 이걸 코틀린이 해결!!!

### Nullable 과 Non-Nullalbe
- 코틀린은 기본적으로 '객체는 null 이 될 수 없다.'고 본다.
- 따라서, 모든 객체들은 생성괴 동시에 초기화 해야 한다.

### 셰이프 콜 연산자 ?
- ? 연산자를 이용하면 메서드 호출, 혹은 객체 프로퍼티 접근과 null체크를 한번에 할 수 있다.
- ? 연산자를 셰이프 콜 연산자(안전 호출 연산자)하며
- 만약 객체가 참조가 null이면 셰이프 콜 연산자의 반환값음 null이 된다.

### 엘비스 연산자 ?:
- 엘비스 연산자는 ? 연산자를 이용해 셰이프콜을 할 시 null을 반환하지 않고, 기본값을 반환한다.

### 확정 연산자 !!
- 절대 null을 아님을 보증하는 연산자.
- 이게 null이 가능한 자료형이긴 한데, 정대 null 이 아니니 걱정마!

## lateinit 키워드와 lazy 키워드
- lateinit은 var로 선언한 변수의 늦은 초기화를 돕고
- lazy는 val로 선언한 상수의 늦은 초기화를 돕는다.

### lateinit 키워드
- 코틀린에서는 기본적으로 모든 변수는 null 아니기 떄문에 선언과 동시에 처기화 되어애 한다.
- 만약 변수 값을 나중에 넣고 싶다면 lateinit 사용
- lateinit 키워드를 사용하면 일단 변수를 선언하고 나중에 값을 할당할 수 있음

### lateinit 을 사용할 때 주의할 점
1. var 변수에서만 사용
2. nullabe 자료형과 함께 사용할 수 없음
3. 초기화 전에 변수를 사용하면 에러가 발생
4. 원시 자료형(Int, Double, Float) 등에는 사용이 불가능
5. **::변수명.isInitialized()** 함수로 함수가 초기화 되었는지 확인할 수 있음

### lazy 키워드
- lazy 키워드를 이용하면 변경할 수 없는 병수인 val의 늦은 초기화를 할 수 있다.
- 객체가 생성될 때 초기화 하는 것이 아니라 처음 호출 될 때 lazy{} 안의 코드가 실행되면서 초기화 됨

## 람다식 "람다식은 마치 값처럼 다룰 수 있는 익명 함수다."
- 람다 표현식, 람다라고 불림
- 람다식을 값처럼 다룰 수 있다는 말은, 람다식 자체가 함수의 인수가 되거나 변환값이 될 수 있다는 말과 같다.

## Single Abstract Method (SAM)
- 람다식이 아닌데도 람다식으로 취급
1. 코틀린 인터페이스가 아닌 자바 인터페이스여야 할 것
2. 인터페이스 내에는 딱 한 개의 추상 메서드만이 존재할 것
- 위와 같은 조건을 만족하는 경우 익명 인터페이스 객체 생성에 람다식을 사용할 수 있음
