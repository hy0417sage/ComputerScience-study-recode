### 1. 먼저 프로세세스 상태 다이어그램을 떠올려 보고, 프린트 사용을 요구한 프로세스가 입출력 작업이 완료되고 난 후 절차에 대해 작성해 보세요.
- 다른건 몰라도 준비 큐와 대기 큐는 있어야 됨 
- '완료 인터럽트 발생'
- '대기 큐'에서 작업이 완료된 PCB 찾기
- PCB를 준비 상태로 변경 후 대기 큐에서 제거
- '준비 큐'로 이동

### 2. 다단계 피드백 큐가 프로세스 우선순위를 관리하는 방식에 대해 설명하고 생각하는 장점을 적어주세요
1. CPU 이용시간이 길면 '우선순위가 낮은 큐'로 이동
2. 낮은 우선순위에서 너무 오래 기다리면 '우선순위 높은 큐'로 이동
3. 기아현상예방

### 3. 세마포에서 특정 프로세스가 임계구역을 실행하고 있다면 다른 프로세스가 임계구역을 요청하고 들어가기 전까지 어떻게 동작하는가?
-> 키워드 : '대기 큐'
- 프로세스의 PCB를 세마포를 위한 대기 큐에 집어 넣는다.
- 다른 프로세스가 임계 구역에서의 작업이 끝나고 'signal 함수를 호출'하면 
- signal 함수는 대기중인 프로세스를 대기 큐에서 제거
- 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨 준다.

### 4. 세마포에서 S, wait, signal 각각의 역할을 설명하고, 세마포를 이용하여 프로세스 순서를 제어하는 방법엔 무엇을 있을지 생각해 보시오.
- S전역 변수, wait : 임계구역에 들어갈 도 될지 알려줌, signal : 임계 구역 앞에서 기다리는 프로세스에 가도 좋다고 알려줌
- 세마포 변수 S를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수, 
- 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 된다.

### 5. CPU가 유효비트가 0일 경우 페이지로 접근하려고 하면 (1)어떤 상황이 생기는지 이를 처리하기 위해 (2)어떤 식으로 동작하는지 작성해 보세요.(정말 단순하게 작성해도 됩니당)
1. 페이지 폴트 발생
2. 하드웨어 인터럽트 처리과정과 유사
    1. CPU 기존 작업 백업
    2. 페이지 폴트 처리 루틴 실행
    3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
    4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 가능해짐

### 6. 프로세스를 통째로 메모리에 중복 저장 하지 않으면서 프로세스끼리 자원을 공유하는 방법은?
- 페이징으로 프로세스간의 페이지를 공유할 수 있다.
- 부모를 복사했을 시 내용이 동일하면 동일한 프레임을 가리킨다.
- 부모, 자식중 어느 하나가 수정된다면 해당 페이지가 별도의 공간으로 복제 된다.
    - 이런 쓰기시 복사로 프로세스 생성 시간을 줄이고 메모리 공간도 절약한다.


### 7. 계층적 페이징의 논리주소를 토대로 주소변환은 어떻게 이루어 지나요?
1. '바깥 페이지 번호'를 통해 페이지 테이블의 페이지를 찾기
2. 페이지 테이블의 페이지를 통해 '프레임 번호'를 찾고 '변위'를 더함으로 '물리주소' 얻기

### 8. 유닉스 파일 시스템에서 (1)색인 블록을 어떤 식으로 부르며, 유닉스 파일 시스템의 (2)블록주소를 저장하는 과정을 간략하게 작성하여 주세요.
- 키워드 'i-node'
1. 블록 주소 12개에는 '직접 블록 주소'를 저장한다.
2. 열세번째 주소에 '단일 간접 블록 주소'를 저장한다.
3. 열네번째 주소에 '이중 간접 블록 주소'를 저장한다.
4. 열 다섯번재 주소에 '삼중 간접 주소'를 저장한다.


### 9. 페이지 폴트란 무엇인가요?
- 페이지 폴트란 무엇인가?
- 페이지 폴트란 프로그램이 자신의 주소 공간(가상메모리공간)에는 존재하지만 
- 시스템의 RAM에는 현재 없는 데이터나 코드에 접근 시도하였을 경우 발생하는 현상을 말한다.


### 10. 작업 로그를 통해 시스템 크래시가 발생했을 때 빠르게 복구하기 위한 방법은? 
- 저널링

---

### 페이지 테이블 베이스 레지스터
- 각 프로세스의 페이지 테이블이 적제된 주소를 가리키고 있다.

- TLB 캐시 메모리를 두어 메모리 접근 시간을 두번 안되게 만듬

- CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 




### 페이징이 내부 단편화 문제를 야기하는 이유
- 모든 프로세스가 페이지 크기에 맞게 잘리는 것이 아니기 떄문에 내부 단변화가 야기된다.

### 페이징 에서의 주소 변환
- 특정 주소에 접근하려면 
1. 어떤 페이지 혹은 프레임에 접근하고 싶은지 
2. 접근하려는 주소가 그 페이지 혹은 프레임으로 부터 떨어져 있는지
- 그래서 페이징 시스템음 모든 논리 주소가 페이지 번호, 변위로 이루어져 있음
- 페이지 번호는 말 그대로 접근하고자 하는 페이지 번호이다. 

### 페이지 테이블 엔트리
- 페이지 테이블의 각각의 행동들을 페이지 테이블 엔드트리라고 한다.
- 페이지 테이블에 있는 중요한 정보
1. 유효 비트 : 현재 해당 페이지에 접근이 가능한지 여부를 알 수 있음, 만일 CPU가 유효비트가 0인 메모리에 적재되어있지 않은 페이지로 접근하려고 하면 패이지 폴트 예외가 발생함
CPU가 페이지 폴트를 처리하는 과정
1. CPU 기존 작업 백업
2. 페이지 폴트 처리 루틴 실행
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 가능해짐

### CPU가 유효비트가 0인 메모리에 적재되어있지 않음 페이지로 접근하려고 하면 어떤 예외가 발생하는지, 이를 처리하기 위해 어떤 식으로 동작하는지 작성해라
1. 페이지 폴트 발생
2. 하드웨어 인터럽트 처리과정과 유사


2. 보호 비트 : 페이지 보호 기능을 위해 존재 / 읽기만 가능한지 둘다 가능한지 알 수 있음

### 보호비트가 101일 경우 어떤 권한이 있는가?
- 읽기와 실행만 가능하다

3. 참조 비트 : CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다. 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 셋팅되고 아닐 경으 0
4. 수정 비트 : 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다. (더티비트)라고도 불림

### 한번도 수정된 적이 없는 페이지가 스왑 아웃 될 경우 아무런 추가 작업 없이 적재된 페이지로 덮어쓰기만 하면된다.


### 페이지 테이블 엔트리ㅔㅇ 수정 비트를 두는 이유는?
- 수정된 적이 있는 페이지가 스왑 아웃 될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가 되어야 한다.

### 페이징이 제공하는 이점
1. 프로세스간의 페이지를 공유할 수 있다.
- 쓰기시 복사


### 프로세스를 통째로 메모리에 중복 저장 하지 않으면서 프로세스끼리 자원을 공유하는 방법은?
- 페이징으로 프로세스간의 페이지를 공유할 수 있다.
- 부모를 복사했을 시 내용이 동일하면 동일한 프레임을 가리킨다.
- 부모, 자식중 어느 하나가 수정된다면 해당 페이지가 별도의 공간으로 복제 된다.
    - 이런 쓰기시 복사로 프로세스 생성 시간을 줄이고 메모리 공간도 절약한다.

### 계층적 페이징의 논리 주소 형태를 설명하세요.
1. 바깥 페이지 번호 : CPU와 근접한 곳에 위치한 페이지 엔트리를 가리킴
2. 안쪽 페이지 번호 : 첫번째 테이블 바깥에 위치한 두번째 테이블, 페이지 테이블 번호를 가리킨다.
3. 변위 : 
- 페이징 테이블을 여러개의 페이지로 나누고 바깥쪽의 페이지 테이블을 하나 더 두어 잘린 페이지테이블을 가리키게 하는 방식


### 계층적 페이징의 논리주소를 토대로 주소변환은 어떻게 이루어 지나요?
1. 바깥 페이지 번호를 통해 페이지 테이블의 페이지를 찾기
2. 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로 물리주소 얻기

### 요구 페이징이란
- 프로세스를 메모라에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만은 메모리에 적재하는 기법
- 실행헤 요구되는 페이지만 적재하는 기법

### 페이지 폴트란 무엇인가?
- 페이지 폴트란 프로그램이 자신의 주소 공간(가상메모리공간)에는 존재하지만 
- 시스템의 RAM에는 현재 없는 데이터나 코드에 접근 시도하였을 경우 발생하는 현상을 말한다.

### 페이지 폴트 빈도가 떨어지게 만드려면 어떤 식으로 동작해야 할까요?ㅋ
1. 순수 요구 페이징

젛은 페이지 교체 알고리즘은
1. 페이지 폴트 횟수를 알고 있어야 한다.
2. 페이지 참조열을 통해 알 수 있다(중복을 제거한다)

### 페이지 교체 알고리즘
1. FIFO 페이지 교체 알고리즘 : 메모리에 가장 먼저 올라온 페이지부터 내쫒는 방식
2. 최적 페이지 교체 알고리즘 : 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
3. LRU 페이지 교체 알고리즘 : 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것

### 스레싱과 프레임 할당
- 프로세스가 사용할 수 있는 프레임 수가 많으면 일반적으로 페이지 폴트 빈도는 감소한다.
- 이건 새로운 페이지를 참조할 댸마다 페이지 폴트가 발생한다.
- 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 스래싱이라고 한다.

### 멀티 프로그래밍 정도
- 메모리에서 동시에 실행되는 프로세스의 수
- 높으면 현재 많은 프로세스가 동시에 실행중
- 낮다면 현재 메모리에는 적은 프로세스가 동시에 실행중

### 프레임 할당 방식
1. 균등 할당 : 크키가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 적게 나눠주는 방식
2. 비례 할당


### 유닉스 파일 시스템
- 색인 할당은 색인 블록(파일의 모든 주소를 하나의 블록에 모아 관리, 을 기반으로 파일의 데이터 블록들을 찾는 방식
- 색인 블록을 i-node라고 함
- 

### 유닉스 파일 시스템의 3중 간접 블록주소를 저장하는 과정을 간략하게 작성하여 주세요.


### 작업 로그를 통해 시스템 크래시가 발생했을 때 빠르게 복구하기 위한 방법은? 