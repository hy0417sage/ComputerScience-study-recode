# 2022-11-28 (월)

## ArrayList vs Array (비교)
|비교|Array|ArrayList| 
|---|---|---|
사이즈|int 값을 사용하여 배열을 초기화 하면 변경할 수 없다.(크기와 용량이 고정되어있다)|크기와 용량이 고정되어있지 않다. List에 있는 요소의 삽입 제거에 따라 논리적 크기가 변경된다.|
|메모리 할당|생성시 배열의 크기와 유형에 따라 할당된다. 기본 유형은 기본값, 참조 유형의 경우 null값으로 모든 요소 초기화 | 성장함에 따라 메모리 할당을 변경한다. 논리적 크기는 0으로 유지되고 arraylist가 초기화 하는 동안 객체를 저장할 수 있는 용량을 지정한다. + (우리는 빈 ArrayList 객체를 위한 특별한 싱글톤 0 크기 배열이 있다는 점에 주목해야 합니다 . 따라서 생성 비용이 매우 저렴합니다. ArrayList가 내부적으로 Object 참조 배열을 사용 한다는 점도 주목할 가치가 있습니다.) |

### ArrayList를 초기화 할 때
- 너무 큰 ArrayList를 만들 경우 메모리 낭비 발생할 수 있음
- 작은 리스트를 만들 경우에도 선호하는 크기보다 작은 데이터를 저장할 경우 메모리 낭비

## 모듈이란?
- 개발하는 애플리케이션이 커지면 언젠가 파일을 여러개로 분리해야함. 이때 분리된 파일 각각을 '모듈' 이라고 부름
- 모듈은 대개 클래스 하나 혹은 특정한 목적을 가진 복수의 함수로 구성된 라이브러리 하나로 구성 됨

## 바이너리 코드란?
- 컴퓨터가 인식할 수 있는 0과 1로 구성된 이진 코드를 의미

## 추상화란? (개방-폐쇄 원칙의 핵심 요소)
- 공통의 속성이나 기능을 묶어 이름을 붙이는 것, 구체적인 것을 감추고 보고 싶어하는 전체적인 특성을 드러내는 것 (데이터의 공통된 성질을 추출하여 슈퍼클래스를 선정하는 개념, 표현의 일부이다.)
- SW 개발 관점에서 추상화란 인터페이스에 의존하고, 구체적인 구현에는 의존하지 않는다. (대표적 : printf())
- 실제 출력에 대해 어떻게 동작하는지 알지 못하지만 무엇을 하는지 알고 사용한다.
- 함수를 작게 만드는것이 핵심, 함수가 하는 일도 하나여야 하한다.(이름만 가지고 무슨 역할을 하는지 명확히 파악 되어애 한다.)
- 파일의 이름이나 디렉토리의 이름도 추상화의 일부이다.
- 내부를 보지 않더라도 이름만으로 어떤 역할을 하는지 파악할 수 있어야 한다.

## 인터페이스란?
- 극단적으로 동일한 목적 하에 동일한 기능을 수행하게끔 강제하는 것이 인터페이스의 역할이자 개념
- 자바의 다형성을 극대화 하여 개발 코드 수정을 줄이고 프로그램 유지보수성을 놓이기 위해 사용

## 추상메소드란? (abstract)
- 자식 클래스에서 반드시 오버라이딩 해야만 사용할 수 있는 메소드를 의미한다.
- 자바에서 추상 메소드를 선언하여 사용하는 목적은 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함이다.
- 예를 들면 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 다 만들어진 것을 사용하고, 이를 받아 사용하는 쪽에서는 자신에게 필요한 부분만을 재정의 하여 사용함으로 생산성이 향상되고 배포등이 쉬워지기 때문
- 이러한 추상 메소드는 선언부에 존재, 구현부는 적지x 

## 추상 클래스 (abstract class)
- 자바에서 하나 이상의 추성 메소드를 포함하는 클래스를 추상 클래스라고 한다. 이러한 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해준다.
- 추상 클래스는 동작이 정의 되어있지 않은 추상 메소드를 포함하고 있으므로, 인스턴스를 생성할 수 없습니다.
- 추상 클래스는 먼저 상속을 통해 자식을 만들고, 만든 자식 클래스에서 추상 클래스의 모든 추상 메소드를 오버라이딩 하고 나서야 비로소 자식 클래스의 인스턴스를 생성할 수 있게 된다.
- 추상 클래스는 추상 메소드를 포함하고 있다는 점을 제외 하면, 일반 클래스와 모든 점이 같다.
- 즉, 생성자와 필드, 일반 메소드로 포함할 수 있다. 

## final
- 클래스 : final이 선언 되어있으면, 상속을 해 줄 수 없다.
- 메소드 : final로 선언 되면 더 이상 overriding 할 수 없다.
- 변수 : final로 선언 되어있으면, 그 변수는 더 바꿀 수 없다.
    - 하지만, 해당 클래스가 final이라고 해서 그 안에 있는 인스턴스 변수나 클래스 변수가 final은 아니라는 부분은 기억하기 (변경할 수 있다)

## 캡슐화
- OOP의 측면
- 객체의 속성과 행위를 하나로 묶고,
- 실제 구현 내용 일부를 내부에 감추어 은닉한다.

## 객체지향 프로그래밍(OOP)
은 컴퓨터 프로그램을 명령어의 목록으로 보는 시간에서 벗어나 여러개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고 받고, 데이터를 처리할 수 있다.

## 함수형 프로그래밍(FP)
은 함수형 응용을 강조한다. 그래서 프로그래밍이 문이 아닌 식이나 선언으로 수행되는 **선언형 프로그래밍** 패러다임을 따르고 있다. 
- side effect가 없는 pure function을 구현함으로 프로그램을 디자인한다. 여러개의 작은 function을 엮으며 하나의 큰 function을 구현하고 불변성을 지키게 됨.
- (+) 
    - 높은 수준의 추상화를 제공한다.
    - 함수 단위의 코드 재사용이 증가한다.
    - 디버깅이 쉽다.
    - 불변성을 지향하기 때문에 프로그램의 동작을 예측하기 쉽다.

## 1급 객체 (First Object, 1급 시민)
- 변수나 데이터 구조안에 담을 수 있다.
- 파라미터로 전달 할 수 있다.
- 반환값으로 사용할 수 있다.
- 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
- 동적으로 프로퍼티 할당이 가능하다.

## SOLID
- OOP 및 설계의 5가지 기본 원칙으로, 프로그래머가 시간이 지나도 유지보수와 확장이 쉬운 시스템을 만들고자 할 때
- '애자일 소프트웨어 개발'과 '적응적 소프트웨어 개발'의 전략적 일부

## 개념
1. S(SRP : Single responsibility principle / 단일 책임 원칙)
    - **"한 클래스는 하나의 책임만 가져야 한다."**
    - 클래스는 그 책임을 완전히 캡슐화 해야 함.
    - 클래스는 자신의 이름이 나타내는 일을 해야하며, 각 클래스는 하나의 개념을 나타내야 한다.
    - 작성된 클래스는 하나의 기능만을 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어야 한다.
    - (+) 책임 영역이 확실해 진다. (한 책임의 변경에서 다른 책임의 변경으로 연쇄작용에서 자유로운 수 있다.)
    - (+) 책임을 적절히 분해함으로 코드의 가독성 향상, 유지보수가 가능해 진다.
    - (주의) 하나의 책임이라는 개념이 관점에 따라 애매할 수 있다(문맥과 상황이 중요)
    - 그래서, 변경이 필요할 때, 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것으로 볼 수 있다.

2. O(OCP : Open/closed principle / 개방-폐쇄 원칙)
    - "소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다."
    - **자신의 확장에는 열려 있어야 하고, 주변의 변화에는 닫혀 있어야 한다.**
    - 모듈중 하나에 수정을 가할 때 그 모듈을 이용하는 다른 모듈을 줄줄이 고쳐야 한다면 프로그램을 수정하기 어렵다. 
    - 시스템의 구조를 올바르게 재조직하여 나중에 이와 같은 유형의 변경이 더 이상 수정을 유발하지 않도록 하는 것.
    - 확장에 열려있다 : 애플리케이션의 요구사항이 변경 될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장 할 수 있다. 모듈이 하는 일을 변경할 수 있다.
    - 수정에 닫혀있다. : 모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다.
    - 추상화는 개방 폐쇄 원칙의 핵심 요소 이며 객체 지향 프로그래밍의 핵심원칙 이다. 이 원칙을 무시하고 프로그래밍을 한다면 OOP의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.
    - (+) 관리가 용이하고 재사용 가능한 코드를 만드는 기반
    - (+) 추상화, 다형성의 매커니즘으로 OOP의 장점을 극대화 

3. L(LSP : Liskov substitution principle / 리스코프 치환 원칙)
    - "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다."
    - 상위 타입의 객체를 하위 타입의 객체로 대체 할 때 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다.
    - 리스코프 치환 원칙이 지켜지지 않는다면, 다형성에 기반한 개방 패쇄 원칙 역시 위반하게 된다.
    - 객체지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 된다.
    - **상속을 할 때는 부모것을 대신해서 사용을 해도 정상 작동 되게끔 상속을 받아야 한다. 그게 안된다면 상속을 받지 않도록 해야한다.**

4. I(ISP : Interface segregation principle / 인터페이스 분리 원칙)
    - "특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다."
    - **클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.**
    - 인터페이스 분리 원칙은 구체적이고 작은 단위들로 분리 시킴으로써 클라이언트 들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
    - 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화 시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.

5. D(DIP : Dependency inversion principle / 의존관계 역전 원칙)
    - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
    - 상위 계층(정책결정)이 하위 계층(세부사항)에 의존하는 전통적인 의존관계를 반전 시킴으로 상위 계층이 하위 계층의 구현으로 부터 독립되게 할 수 있다.
        - 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위모듈과 하위 모듈 모두 추상화에 의존해야 한다.
        - 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.
    - 이 원칙은 '상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다.' 는 객체 지향적 설계의 대 원칙을 제공한다.