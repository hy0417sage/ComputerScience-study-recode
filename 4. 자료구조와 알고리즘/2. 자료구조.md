# ◼️ 1. 배열
- 데이터를 나열하고, 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조
- 파이썬에서는 리스트 타입이 배열 기능을 제공하고 있음

### 배열이 왜 필요할까?
- 같은 종류의 데이터를 *순차적으로 저장*하여 효율적으로 관리하기 위해 사용하기 위해서 필요합니다.

### 배열의 장점
- 순차적으로 저장되어있어 빠른 접근이 가능합니다.
### 배열의 단점
- 크기가 정해져 있어서 추가/삭제가 쉽지 않는다는 단점이 있습니다.
    - 불변적이라는 단점을 가지고 있다.
    - 최대 길이를 알지 못하면 삽입하는데 어려움이 있고
    - 특정 인덱스 값 삭제시 기존 값들을 앞으로 당겨야 하는 단점이 있다.

# ◼️ 2. 큐
- 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조입니다.
    - 운영체제와 네트워크에 많이 쓰이는 개념!

### 큐에서 알아야 하는 용어
- Enqueue : 큐에 데이터를 넣는 기능
- Dequeue : 큐에서 데이터를 꺼내는 기능

### 우선순위 큐 - 큐가 변형 된 구조1
- 데이터마다 우선순위를 넣어서, 우선순위가 높은 순으로 데이터를 출력

### Lifo 큐 - 큐가 변형 된 구조2
- 나중에 입력된 데이터가 먼저 출력되는 구조(스택 구조라고 보면 됨)


### 어디에 큐가 많이 쓰일까?
- 멀티 태스킹을 위한 프로세스 스케줄링 방식을 구현하기 위해 많이 사용됩니다. (운영체제)
    - 큐의 경우에는 장단점 보다는 (특별이 언급되는 장단점이 없음), 큐의 활용 예로 프로세스 스케줄링 방식을 함께 이해해 두는 것이 좋다.


# ◼️ 3. 스택
- 가장 나중에 쌓은 데이터를 가장 먼저 뺄수 있는 구조입니다.
- 한쪽 끝에서만 자료를 넣거나 뺄 수 있어 데이터를 제한적으로 접근할 수 있는 구조입니다.

### 스택 구조
- 스택은 LIFO 또는 FILO 데이터 관리 방식을 따릅니다.
- 대표적인 스택의 활용으론 프로세스 구조의 함수 동작 방식이 있습니다.

### 스택 구조와 프로세스 스택
- 스택 구조는 프로세스 실행 구조의 가장 기본 입니다.
    - 함수 호출시 프로세스 실행 구조를 스택과 비교해서 이해하는 것이 필요하다.

### 프로세스에서 함수가 어떻게 동작하는 지, 이게 스택 자료구조와 어떤식으로 연관지어 있는지 생각해보기
<img width="546" alt="" src="https://user-images.githubusercontent.com/97173983/217514297-c5c520fb-0983-4be0-a67c-e732ac24b49b.png">

- 함수 위에 함수가 호출이 되면 스택과 같은 구조로 쌓인다.
- 맨 위에 있는 함수가 끝나면 그 다음 함수가 실행되는 것이 반복된다.
- 이런 형태로 프로세스가 동작한다. 이 형태를 구현하는데 가장 유용한 자료구조가 스택이다.
- 그래서 스택이라는 자료구조를 스택 동작방식에 사용한다.

### 스택의 장단점
- 장점
    - 구조가 단순해서, 구현하기 쉽다.
    - 데이터 저장/읽기 속도가 빠르다.
- 단점(일반적인 스택 구현 시)
    - 데이터 최대 갯수를 미리 정해야 한다.
        - 파이썬의 경우 재귀함수는 1000번 까지만 호출이 가능하다.(미리 1000번 만큼만 공간을 확보해놓았기 때문이다.)
    - 저장 공간의 낭비가 발생할 수 있다.
        - 미리 최대 갯수만큼 저장 공간을 확보해야한다.
- 스택은 단순하고 빠른 성능을 위해서 사용되므로, 보통 배열 자료구조를 활용해서 구현하는 것이 일반적이다. 이 경우, 위에서 열거한 부분이 단점이 될 수 있다.


# ◼️ 4. 링크드 리스트
- 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조이다.
- 크기가 정해져 있는 배열의 단점을 해결하기 위해서 나온 것이 링크드리스트이다.
- 미리 예약하지 않고 필요할 때마다 데이터를 추가 할 수 있는 구조
    - 일종의 배열의 단점을 극복한 자료구조가 링크드 리스트이다.

### 링크드 리스트의 기본 구조와 용어
- 노드 : 데이터 저장 단위(데이터 값, 포인터)로 구성
- 포인터 : 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간
<img width="550" alt="" src="https://user-images.githubusercontent.com/97173983/217518263-9fd3c07d-a288-4901-bee3-c4684eff9673.png">

### 링크드 리스트의 장단점
- 장점 
    - 미리 데이터 공간을 할당하지 않아도 됨
        - 배열은 미리 공간을 할당 해야한다.
- 단점
    - 연결을 위한 별도의 데이터 공간이 필요하므로, 저장 공간 효율이 높지 않음
    - 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
    - 중간 데이터 삭제시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요

### 링크드 리스트의 변형 - 더블 링크드 리스트
- 링크드 리스트의 단점 : 반드시 맨 앞에 있는 헤드 데이터를 찾아서 주소를 가지고 원하는 데이터로 이동을 해야 한다.
    - 후반부도 연결해 주면 검색이 좀더 빠르게 될것! -> 더블 링크드 리스트
<img width="481" alt="" src="https://user-images.githubusercontent.com/97173983/217525988-251053a5-6ec6-4233-a5a5-4ea06f26547a.png">

- 기존 링크드 리스트인 항상 앞에서 검색을 해야하는 단점을 보안한것이 더블 링크드 리스트이다.
<img width="387" alt="" src="https://user-images.githubusercontent.com/97173983/217526337-615a3ede-6bd0-446d-86b1-726b73b64177.png">


# ◼️ 5. 해쉬 테이블
### 해쉬 구조
- Hash Table : 키에 데이터를 저장하는 구조
    - Key를 통해 바로 데이터를 받아올 수 있으므로, 속도가 획기적으로 빨라짐
    - 파이썬 딕셔너리 타입이 해쉬 테이블의 예이다.
    - 보통 배열로 미리 Hash Table 사이즈만큼 생성 후에 사용 (공간과 탐색 시간을 맞바꾸는 기법)
    - 단, 파이썬에서는 해쉬를 별도로 구현할 필요가 없음 - 딕셔너리 타입을 사용하면 됨

### 용어
- 해쉬 : 임의 값을 고정 길이로 변환 하는것
- 해쉬 테이블 : 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
- 해싱 함수 : Key에 대해 산술 연산을 이용해 데이터의 위치를 찾을 수 있는 함수
- 해쉬 값, 해시 주소 : Key를 해싱 함수로 연산해서, 해쉬 값을 알아내고, 이를 기반으로 해쉬 테이블에서 해당 Key에 대한 데이터 위치를 일관성 있게 찾을 수 있음
- 슬롯 : 한 개의 데이터를 저장할 수 있는 공간
- 저장할 데이터에 대해 Key를 추출할 수 있는 별도 함수도 존재할 수 있음
<img width="228" alt="" src="https://user-images.githubusercontent.com/97173983/217534157-56c4748b-2996-48c1-a255-03a69e3eb4d5.png">

### 해시의 역할 - 해시를 쓰지 않는다면?
<img width="622" alt="" src="https://user-images.githubusercontent.com/97173983/217714974-2514c4f2-c771-47b7-ac3b-855b2d95df5e.png">

### 자료구조 해쉬 테이블의 장단점과 주요 용도
- 장점 
    - 데이터 저장/읽기 속도가 빠르다. (검색 속도가 빠르다)
    - 해쉬는 키에 대한 데이터가 있는지 (중복) 확인이 쉽다.
- 단점
    - 일반적으로 저장공간이 좀 더 많이 필요하다.
    - **여러 키에 해당하는 주소가 동일한 경우 충돌을 해결하기 위한 별도 자료구조가 필요**하다.
- 주요 용도
    - 검색이 많이 필요한 경우
    - 저장, 삭제, 읽기가 빈번한 경우
    - 캐쉬 구현 시(중복 확인이 쉽기 때문)
        - 예로 웹 브라우저에서 매번 페이지를 읽을 때마다 이미지와 데이터를 가져오게 되면 X, 미리 저장하여 바뀐 데이터만 보여줌 -> 데이터가 있냐 없냐

## 해쉬 충돌 해결 알고리즘(좋은 해쉬 함수 사용하기)
- 해쉬 테이블의 가장 큰 문제는 충돌의 경우이다.
- 이 문제를 충돌 또는 해쉬 충돌 이라고 부른다.

### Chaining 기법 - 해쉬 충돌 해결 알고리즘1
- **Open Hashing** 기법 중 하나로 해쉬 테이블 저장 공간 외의 공간을 활용하는 기법
- 충돌이 일어나면, 링크드 리스트라는 자료구조를 사용해서, 링크드 리스트로 데이터를 추가로 뒤에 연결시켜서 저장하는 기법

### Linear Probing 기법 - 해쉬 충돌 해결 알고리즘2
- **Close Hashing** 기법 중 하나로 해쉬 테이블 저장 공간 안에서 충돌 문제를 해결하는 기법이다.
- 충돌이 일어나면, 해당 hash address의 다음 address 부터 맨 처음 나오는 빈 공간에 저장하는 기법
    - 저장 공간 활용도를 높이기 위한 기법

## 해쉬의 시간 복잡도
- 일반적인 경우 (저장, 검색 등) : O(1)이 걸린다 (충돌이 없다면)
- 최악의 경우(충돌이 전부 발생할 경우) : O(n)이 걸린다.

### 검색에서 해쉬 테이블의 사용 예
- 16개의 배열에 데이터를 저장하고, 검색할 때 O(n)
- 16개의 데이터 저장공간을 다진 위의 해쉬 테이블에 데이터를 저장하고, 검색할 때 O(1)


# ◼️ 6. 트리 자료구조
- 트리 : Node와 Brach를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조
- 실제로 어디에 많이 사용되나?
    - 트리 중 이진 트리 형태의 구조로, 탐색 알고리즘 구현을 위해 많이 사용됨

### 알아둘 용어
- Node : 크리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)
- Root Node : 트리의 맨 위에 있는 노드
- Level : 최상위 노드를 Level0으로 하였을 때, 하위 Branch로 연결된 깊이를 나타냄
- Parent Node : 어떤 노드의 다음 레벨에 연결된 노드
- Child Node : 어떤 노드의 상위 레벨에 연결된 노드
- Leaf Node : Child Node 가 하나도 없는 노드
- Silbing : 동일한 Parent Node를 가진 노드
- Depth : 트리에서 Node 가 가질 수 있는 최대 level 

### 이진트리 - 가장 많이 쓰이는 트리
- 자식이 최대 2개로 이뤄져 있다.
<img width="300" alt="" src="https://user-images.githubusercontent.com/97173983/217718550-680e675f-85c2-4d9b-ad61-8fbb78bea2cd.png">

### 이진트리와 이진탐색 트리
- 이진 트리 : 노드의 최대 Branch가 2인 트리
- 이진 탐색 트리(BST) : 이진 트리에 '왼쪽 노드는 부모 노드보다 작은 수, 오른쪽 노드는 부모 노드보다 큰 수여야 한다.' 이러한 규칙이 추가된 트리이다.

### 이진 탐색 트리의 장점과 주요 용도
- 주요 용도 : 데이터 검색(탐색)
- 장점 : 탐색 속도를 개선할 수 있음
- 단점 : 복잡하다

### 이진 탐색 트리의 삭제
- 매우 복잡하다. 경우를 나누어서 이해하는 것이 좋다

#### leafNode 삭제
- Leaf Node : 자식 노드가 없는 Node
- 삭제할 Node의 parent Node 가 삭제할 Node가 가리키지 않도록 한다.
<img width="403" alt="" src="https://user-images.githubusercontent.com/97173983/217719860-4f67eb7d-145f-446c-b60b-9f1492d46ccf.png">

### 이진 탐색 트리의 시간 복잡도와 단점
- 탐색시 시간 복잡도
    - 트리의 높이를 h라고 표기한다면, O(h)
    - n개의 노드를 가진다면, h = log2n에 가까우므로, 시간 복잡도는 O(logN)
        - 참고 : 빅오 표기법에서 logN에서의 Log 밑은 10이 아니라, 2 이다.
            - 한번 실행시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미, 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미함
<img width="247" alt="" src="https://user-images.githubusercontent.com/97173983/217721086-140e5389-8509-4495-9c03-1a7082598f45.png">

### 이진 탐색 트리의 단점
- 평군 시간 복잡도는 O(logn) 이지만, 
    - 이는 트리가 균형 잡혀있을 때의 평균 시간복잡도이며, 
- 아래와 같이 구성되어 있을 경우, 최악의 경우는 링크드 리스트 등과 동일한 성능을 보여줍니다.
![image](https://user-images.githubusercontent.com/97173983/217721778-89393ee0-636c-4a57-897b-688608253efa.png)

# ◼️ 힙 - 완전 이진 트리
- 트리를 기반으로 특정한 목적에 맞춰 변형된 자료구조 입니다.
- 힙 : 데이터에서 최대값과 최솟값을 빠르게 찾기 위해 고안된 완전 이진 트리
    - 완전 이진 트리 : 노드를 삽입할 때 최하다 왼쪽 노드부터 차례대로 삽입하는 트리
    
<img width="166" alt="" src="https://user-images.githubusercontent.com/97173983/217738650-bd9db0de-e072-46e2-ad35-671289aafe2c.png">

- 힙을 사용하는 이유
    - 배열에 데이터를 넣고, 최대값과 최솟값을 찾으려면 O(n)이 걸림
    - 이에 반해, 힙에 데이터를 넣고, 최대값과 최솟값을 찾으면, O(logN)이 걸림
    - 우선순위 큐와 같이 최대값 또는 최솟값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용됨