# HTTP

## HTTP란?
- HTTP는 클라이언트-서버 모델로 리퀘스트와 리스폰스 구조로 웹 상에서 정보를 주고 받을 수 있는 프로토콜 입니다. TCP/IP 기반으로 동작하며 가장 큰 특징으론 Connectionless와 stateless가 있습니다.

## 배송을 담당하는 IP
- IP 주소(논리주소) : 각 노드에 부여된 주소
- MAC 주소(물리주소) : 각 네트워크에 할당된 주소
- 통신은 ARP에 의존해서 통신을 한다.
- ARP : 수신지의 ip주소를 바탕으로 mac주소를 조사할 수 있다. 다음으로 중계할 곳의 mac주소를 사용하여 mac주소를 찾아가는 것

## 신뢰성을 담당하는 TCP
- 신뢰성 있는 바이트스트림 서비스를 제공한다.
- 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인하는 역할

### SYN ACK TCP 플래그를 사용한다.
- 3-way 핸드셰이크

## 이름 해결을 담당하는 DNS
- 응용 계층 시스템에서 도메인 이름과 IP주소 이름 확인을 제공한다.
- DNS 는 도메인명에서 IP 주소를 조사하거나 반대로 IP 주소로부터 도메인 명을 조사하는 서비스를 제공한다.

## 각각와 HTTP와의 관계
![](/%20reference%20material/network/http%EC%99%80%20%EA%B4%80%EA%B3%84.png)

## HTTP 쿠키와 세션
- HTTP는 상태를 유지하지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있습니다.
- 또한 단순한 프로토콜이기 때문에 HTTP가 다양한 곳에서 이용되는 측면조 있습니다.
- 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트 상채를 파악하기 위한 시스템입니다.

## 서버에 임무를 부여하는 HTTP 메서드 GET, POST
- Get은 가져온다는 개념이고, post는 수행한다는 개념을 받아드리면 쉽다.
- 즉 Get은 서버에서 어떤 데이터를 가져와서 보여줄 때 사용한다. 어떤 값이나 내용, 상태 등을 바꾸지 않는 경우에 사용하는 것
- 이에 비해 Post는 서버상의 데이터 값이나 상태를 바꾸기 위해 사용한다.
- 게시판으로 예를 들면, 글의 내용에 대한 목록을 보여주는 경우나, 글의 내용을 보는 경우는 get에 해당합니다. 그리고 글의 내용을 저장하고, 수정할 때에 post를 사용한다.
- GET은 데이터를 읽거나 검색할 때에 사용되는 메서드이다. GET는 요청을 전송할 때 URL 주소 끝에 파라미터로 포함되어 전송되며, 이 부분을 쿼리 스트링이라고 한다. 오로지 데이터를 읽을 때만 사용되고 수정할 때는 사용하지 않습니다.
- POST는 GET과 달리 전송해야 하는 데이터를 HTTP 메시지의 Body에 담아서 전송합니다. 그리고 그 바디의 타입은 효청 헤더의 Content-type에 요청 데이터의 탐입을 표시 따라 결정됩니다. HTTP 메시지의 Body는 길이의 제한 없이 데이터를 전송할 수 있다. 그래서 POST 요청은 GET과 달리 대용량 데이터를 전송할 수 있는 이유도 이 때문이다.

## 지속연결로 접속량을 절약
- 매번 connection 연결 후 리스폰스 까지 하고 종료가 아니라 지속 연결을 하면 
1. 서버에 대한 부하가 경감되고
2. 웹 페이지를 빨리 표시할 수 있다.

## 파이프라인화
- 지속 연결은 파이프라인화를 가능하게 한다.
- 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.
- 쿠키를 사용해서 상태 관리 - 쿠키는 리퀘스트와 리스폰스에 쿠기 정보를 추가해서 클라이언트 상태를 파악하기 위한 시스템

# 3장 HTTP 정보는 GTTP 메세지에 있다.
- HTTP에서 교환하는 정보를 HTTP 메세지라고 한다.

## 인코딩으로 전송 효율을 높이다.
- 다량의 액세스 효율 좋게 처리 가능
- CPU 등의 리소스는 보다 많이 소비하게 됨
1. 콘텐츠 코딩 - 엔티티 정보를 유지한 채로 압축한다.
2. 청크 전송 코딩 - 엔티티 바디를 분할해 사이즈가 큰 코딩을 전송한다.
3. 멀티파트 - 여러 데이터를 보냄 (텍스트, 영상, 이미지)

### 레인지 리퀘스트 - 범위를 지정하여 리퀘스틑 하는 것
- 다운로드 중 커넥션이 끊어지게 되면 처음부터 다시 다운로드 -> **리줌** 기능 필요 : 이전에 다운로드 한 곳에서 부터 다시 다운로드 재개

### 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
- 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조

### 메시지 바디와 엔티티 바디의 차이
- 메시지 - HTTP 통신의 기본 단위로 옥텟 시퀀스로 구성되고 통신을 통해서 전송된다.
- 엔티티 - 리퀘스트랑 리스폰스의 페이로드로 전송되는 정보로 엔티티 헤더와 엔티티 바디로 구성된다.

# 4장 : 상태코드
### 2XX 성공 : 리퀘스트가 정상 처리됨
- 200 OK 정상 처리
- 204 리퀘스트 성공, but 돌려줄 ㄹ리소스 없음
- 206 일부만 리퀘스트 성공

### 3xx 리다이렉트 : 리퀘스트가 정상적으로 처리를 종료하기 위해 브라우저 측에서 특별한 처리를 수행

### 4xx : 클라이언트 에러
- 400 잘못된 리퀘스트
- 401 유저 인증 실패
- 403 리소스 액세스 거부
- 404 리소스 서버에 없음

### 5xx 서버 에러

# 5장 : HTTP와 연계하는 웹서버

## 1대로 도메인을 가능하게 하는 가상 호스트
- 같은 IP 주소에서 다른 호스트명과 도메인 명을 가진 여러개의 웹 사이트가 실행되고 있는 가상 호스트의 시스템이 있기 때문에,
- HTTP 리퀘스트를 보내는 경우에는 호스트 명과 도메인 명을 완전하게 포함된 URI를 지정하거나, 반드시 Host 필드에서 지정해야한다.

## 통신을 중계하는 프로그램 : 프록시, 게이트웨이, 터널
1. 프록시 - 서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램으로, 클라이언트로 부터의 리퀘스트를 서버에 전송하고, 서버로부터 리스폰스를 클라이언트에 전송한다.
2. 게이트웨이 - 다른 서버를 중계하는 서버로, 클라이언트로부터 수신한 리퀘스트를 리소스를 보유한 서버인 것 처럼 수신한다. 경우에 따라서 클라이언트는 상대가 게이트웨이라는 것을 알지 못하는 경우도 있다.
3. 터널 - 서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계 프로그램
- 리소스 본체를 가진 서버를 오리진 서버라고 부른다.

### 프록시
- 프록시 서버를 사용하는 이유는 
1. 나중에 설명할 캐시를 사용해서 **네트워크 대역등을 효율적으로 사용**하는 것과 
2. 조직 내에 특정 웹 사이트에 대한 액세스 제한, 액세스 로그를 획득 하려는 정책을 철저하게 지키려는 목적으로 사용

#### 1. 캐싱 프록시
- 프록시로 리스폰스를 중계하는 때에 프록시 서버 상에 리소스 캐시를 보존해 두는 프록시

#### 2. 투명 프록시
- 프록시로 리퀘스트와 리스폰스를 중계를 할 때 메시지 변경을 하지 않는 타입의 프록시를 투명 프로시라고 한다.
- 반대로 메시지에 변경을 가하는 타입을 비투과 프록시라고 한다.

### 게이트웨이 - 통신의 안전성을 높임
- 프록시와 유사, 게이트웨이의 경우 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버
- 클라이언트와 게이트웨이 사이를 암호화 하는 등으로 안전하게 접속함으로 **통신의 안전성을 높이(ex. 신용카드)**는 역할을 한다.

### 터널 
- **요구에 따라서 다른 서버와의 통신 경로를 확립**한다.
- 이때 클라이언트는 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신을 하기 위해 사용한다.
- 터널 자체는 리퀘스트를 해석하려고 하지 않는다. 결국 리퀘스트를 그대로 다음 서버에 중계한다. 양쪽 끝의 접속이 끝어질 때 종료한다.

## 리소스를 보관하는 캐시
- 캐시는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본을 가리킨다.
- 캐시를 사용하면 리소스를 가진 서버에의 액세스를 줄이는 것이 가능하다 -> 통신량과 통신 시간을 절약할 수 있다.
- 장점 : 같은 데이터를 몇번이고 오리진 서버에 전송할 필요가 없다.

### 캐시에 유효 기간이 있는 이유는?
- 캐시 서버는 갱신되기 전의 낡은 리소스를 그대로 보냄

### 클라이언트 측에도 캐시가 있다.
- 캐시 서버와 마찬가지로 리소스가 오래된 것으로 판단되는 경우 오리진 서버에 리소스의 유효성을 확인하러 가거나 새로운 리소스를 다시 획득하러 감

# 6장 HTTP 헤더
- 메세지 헤더에는 클라이언트나 서버가 이퀘스트 리스폰스를 처리하기 위한 정보가 들어있다.

### 리퀘스트 HTTP 메세지
1. 리퀘스트 라인 - 메소드, URI, HTTP 버전
2. 리퀘스트 헤더 필드
3. 일반 헤더 필드
4. 엔티티 헤더 필드

### 리스폰스의 HTTP 메세지
1. 상태 라인 - HTTP 버전, 상태 코드
2. 리스폰스 헤더 필드
3. 일반 헤더 필드
4. 엔티티 헤더 필드

## HTTP 헤더필드는 중요한 종보를 전달한다.
- 부가적으로 중요한 정보를 전달하는 역할을 담당
~~~
헤더 필드 명 : 필드 값
~~~

## HTTP 헤더 필드 - 4종류
1. 일반적 헤더 필드 - 리스폰드, 리퀘스트 메시지 둘다 해당
2. 리퀘스트 헤더 필드 - 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로 리퀘스트의 부가적 정보와 클라이언트 정보, 리스폰스의 콘텐츠에 관한 우선순위 등을 부여한다.
3. 리스폰드 헤더 필드 - 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가한다.
4. 엔티티 헤더필드 - 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더러 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가한다.

## HTTP 헤더 필드는 캐시와 비 캐시 프록시의 동작을 정의하기 위해 두 가지 카테고리로 분류
1. End-to-end 헤더 - 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. 캐시에서 구축된 리스폰스 중 보존 되어야 하고, 다시 전송되지 않으면 안됨
2. Hop-by-hop 헤더 - 한번 전송에 대해서만 유효, 캐시와 프록시에 의해서 전송되지 않는 것도 있다.

## Connection 헤더 필드
1. 프록시에 더 이상 전송하지 않는 헤더 필드를 지정
2. 지속적 접속 관리

## Via 
- 클라이언트와 서버간의 리퀘스트 혹은 리스폰스 메세지의 경로를 알기 위해 사용됨

# 7장. 웹을 안전하게 지켜주는 HTTPS

## HTTP의 약점
1. 평문이기 때문에 **도청 가능** - TCP/IP는 도청 가능한 네트워크
2. 통신 상대를 확인하지 않기 때문에 **위장 가능** 
3. 완전성을 증명할 수 없기 때문에 **변조 가능**

### SSL
- SSL은 암호화 뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공한다.

### 1. 평문이기 때문에 도청 가능 해결 방안 - 도청 피하기
- **통신 암호화** : **SSL**이나 **TLS**이라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화 할 수 있다.
- **콘텐츠 암호화** : HTTP 메세지에 포함되는 콘텐츠만 암호화 하는 것

### 2. 통신 상대를 확인하지 않기 때문에 위장 가능 해결 방안 - 위장 피하기
- 상대를 확인하는 **증명서 발급** : **SSL**로 상대를 확인할 수 있다. 이 증명서는 신뢰할 수 있는 제 3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재한다는 사실을 증명한다.
    - 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 개인 정보 누설 등의 위험성이 줄어들게 된다.

### 3. 완전성을 증명할 수 없기 때문에 변조 가능 해결 방안 - 변조 피하기
- 중간자 공격 : 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 할지 모름
- 변조를 방지하려면 : **MD5**이나 **SHA-1** 등의 **해시 값을 확인하는 방법**과 파일의 **디지털 서명을 확인**하는 방법이 있다.

## 결국 HTTPS = HTTP + 암호화 + 인증 + 완전성 보호
- HTTP의 문제를 해결하기 위해 HTTP에 암호화나 인증 등의 구조를 더함
- HTTPS는 SSL의 껍질을 덮어쓴 HTTP이다.
- HTTP 통신을 하는 소켓 부분을 SSL이나 TLS이라는 프로토콜로 대체한다.
    - 그럼 HTTP는 SSL와 통신하고 SSL이 TCP와 통신하게 된다.

# SSL

## SSL에서는 공개키 암호화 방식을 사용한다. - 공통키 암호화의 딜레마
- 공통키 암호화의 딜레마 - 암호화도 복호화도 같은 키를 사용한다. - 키를 넣으면 누구라도 암호를 해독할 수 있다.

### 두 개의 키를 사용하는 공개 키 암호 
- 서로 다른 두 개의 키 페어를 사용한다.
    - 공개키 암호를 사용한 암호화는 암호를 보내는 측이 **상대의 공개키를 사용해 암호화**를 한다.
    - 암호화된 정보를 받아들인 상대는 **자신의 비밀키를 사용해 복호화**를 한다.

### 모든 통신에 공개키 암호를 사용하는 것은 비효율 적이다.
- 공개키 암호는 공통키 암호보다 처리가 느리기 때문에, 모든 통신에 공개키 암호를 사용하는 것은 비 효율적이다.

### 공개키가 정확한지 아닌지를 증명 - CA
- 서버가 발행한 공개키인지 증명 - 도중에 공격자가 공개키를 바꿔치기 했을지도 모름
- 이 문제를 해결하는 데는 인증기관(CA) 와 그 기관이 발행하는 공개키 증명서가 이용되고 있다.

### 인증기관 CA 이용 방법
1. 서버의 운영자가 인증 기관에 공개키를 제출
2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만든다.
3. 공개키 인증서에 서명이 끝난 공개키를 담는다.
4. 서버는 이 인증 기관에 의해 작성된 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신한다.
- 증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해서 서버의 공개키를 인증한 것이 진짜 인증기관이라는 것과 서버의 공개키가 신뢰할 수 있다는 것을 알 수 있다.

### SSL과 TLS
- HTTPS에서는 SSL과 TLS라는 두개의 프로토콜이 사용되고 있다.
- SSL 통신이 느린(지연) 이유 
    1. 통신 속도가 떨어짐
    2. CPU나 메모리 등의 리소스를 다량으로 소비함

### 왜 항상 HTTPS를 사용하지 않는가?
- 평문 통신에 비해 암호화 통신은 CPU나 메모리 등 리소스가 많이 필요하기 때문이다.
- 그렇기 때문에 민감한 정보를 포함하지 않은 통신에서는 HTTP를 사용한다.

# 8장. 누가 액세스 하고 있는지를 확인하는 인증
- 패스워드
- 전자 인증서
- IC 카드 등

## HTTP에서 사용하는 인증 방법
- BASIC 인증 : 웹 서버와 대응하고 있는 클라이언트 사이에서 이루어지는 인증
- DIGEST 인증(챌린지 리스폰스 방식) : 최초에 상대방에게 인증 요구를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산
- SSL 클라이언트 인증 : 유저 ID와 패스워드 정보가 도난당했을 때 제 3자가 위장한다. -> SSL 클라이언트 인증이 이 대책 중 하나.
    - 2-factor 인증에서 사용한다. : 패스워드라는 한 개의 요소만이 아닌 이용자가 가진 다른 정보를 병용해서 인증을 하는 방법
- 폼베이스 인증 : 클라이언트가 서버 상의 웹 어플리케이션 자격 정보를 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식
    - 인증의 대부분은 폼베이스 인증이다.

### 폼베이스 인증
- 폼베이스 인증은 인증 자체는 서버 측의 웹 애플리케이션 등에 의해서 클라이언트가 송신해온 유저 ID와 패스워드가 사전에 등록하고 있는 것과 일치하는지 어떤지를 검증
- 그러나!! **HTTP는 stateless 프로토콜이다!**
- 때문에 방금 전에 인증을 성공핸던 유저라는 상태를 프로토콜 레벨에서는 유지할 수 없다. 즉, 상태 관리가 안되기 때문에 다음에 그 유저가 액세스 했다고 하더라도 다른 유저와 구별하지 못함. 그래서 세션 관리와 쿠키를 사용하여 HTTP에 없는 상태 관리 기능을 보충한다.

# 9장. HTTP에 기능을 추가한 프로토콜
1. SPDY : 스피디, HTTP의 병목 현상을 해소하고 웹 페이지 로딩 시간을 50% 단축한다는 목표를 세우고 개발

### HTTP 병목 현상이란?
- 시스템의 전체 성능이나 용량이 하나 혹은 소수개의 구성 요소나 자원에 의해 제한받는 현상을 말한다.
- HTTP에서는 서버의 정보가 갱신되었는지 아닌지를 알기 위해서 클라이언트가 항상 서버측에 확인하러 가야 한다. -> 서버상의 정보가 갱신되지 않은 경우, 불필요한 통신 발생
1. ajax에 의한 해결 방법 : 웹 페이지의 일부분만 고쳐쓸 수있는 비동기 통신 방법
    - 페이지의 일부분만 갱신되기 때문에 리스폰스로 전송되는 데이터 양은 줄어든다는 장점이 있다.
2. Comet에 의한 해결 방법 : 서버측의 콘텐츠에 갱신이 있을 경우, 클라이언트로부터 리퀘스트를 기다리지 않고 클라이언트에 보내기 위한 방법.
    - 커넥션을 유지하여 리스폰스 보류, 커넥션을 유지하는 동안 리소스를 소비함
3. SPDY의 목표 : 근본적인 개선을 위해 프로토콜 래벨에서의 개선이 필요하다.

### SPDY 설계와 기능
- TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 들어감으로써 데이터의 흐름을 제어하지만, HTTP의 커넥션은 확립되어있다.
- HTTP의 GET이나 POST와 같은 메소드나 쿠키, HTTP 메시지 등을 그대로 사용할 수 있다.

## 브라우저에서 양방향 통신을 하는 웹소켓
- 웹소켓은 새로운 프로토콜과 API에 의해 병목현상을 문제를 해결하기 위한 기술로서 개발되었다.

### WebSocket 프로토콜 - 양방향 통신이 가능하다.
- 웹 서버와 클라이언트가 한번 접속을 확립하면 그 뒤의 통신을 모두 전용 프로토콜로 하는 방식
- HTTP에 의한 접속의 출발점이 클라이언트에 있다는 것에는 변함이 없지만, 한번 접속이 확립되면 websocket 을 사용하여 서버와 클라이언트 어느 쪽에서도 송신을 할 수 있게 된다.

### WebSocket 기능
1. 서버 푸시 기능 - 서버는 클라이언트의 리퀘스트를 기다리지 않고 데이터를 보낼 수 있다.
2. 통신량의 삭감 - 접속을 한번 확립하면 접속을 유지하려고 한다.
    - 통신을 하기 위해 핸드쉐이크 절차를 밟을 필요가 있다.

# 10장. 웹 콘텐츠에서 사용하는 기술
- 웹 페이지 대부분은 HTML로 되어 있다. - 웹 상에서 하이퍼텍스트를 보내기 위해서 개발된 언어. / HTML로 쓰여진 문서를 브라우저가 해석해서 렌더링 처리한 결과가 웹 페이지에 표시된다.
- DOM - HTML을 조작하기 쉽게 해줌. - HTML 문서와 XML 문서를 위한 API
- GCI - 웹서버와 프로그램을 연계함 - 웹 서버가 클라이언트에서 받은 리퀘스트를 프로그램에 전달하기 위한 구조 - 동적으로 콘텐츠를 생성할 수 있다.
- 서블릿 - 동적 컨텐츠를 생성하기 위한 프로그램 - CGI는 리퀘스트마다 프로그램을 가동하기 때문에 대량으로 액세스가 있을 때 웹 서버에 부하가 걸리게 되지만, 서블릿에서는 웹 서버와 같은 프로세스 속에서 동작하기 떄문에 비교적 부하를 적게하여 동작시킬 수 있다.
- 갱신정보를 송신하는 RSS/Atom

# 11장 웹 공격의 기술
- 공격 대상은 HTTP를 이용한 서버와 클라이언트 그리고 서버 상에서 동작하는 웹 어플리케이션 등의 리소스이다. - HTTP 자체가 공격 대상이 되지는 않음

### 웹어플리케이션 공격 패턴
## 능동적 공격 - SQL 인젝션, OS 커맨드
- 공격자가 직접 웹 애플리케이션에 엑세스해서 공격 코드를 보내는 타입

### SQL 인젝션
- 부정한 SQL을 실행하는 SQL 인젝션
- 웹 애플리케이션을 이용하고 있는 데이터베이스에 SQL을 부정하게 실행하는 공격이다.
    - SQL 문장의 구분을 파괴한다.

### OS 커맨드 인젝션
- 웹 애플리케이션을 경유하여 OS 명령을 부정하게 실행하는 공격이다.
    - 예시. 송신 버튼 -> 공격자 입력값에 ; 붙이기 커맨드 실행된 후 일단락 -> 계정정보가 포함된 파일이 헤커 이메일로 전송

## 수동적 공격 - XSS, CSRF
- 함정을 이용해서 유저에게 공격 코드를 실행시키는 공격
- 수동적 공격을 이용하면 인트라넷 같은 인터넷에서 직접 액세스할 수 없는 네트워크를 공격할 수 있습니다.
- 많은 인트라넷에서는 인터넷 상의 웹 사이트에 액세스 하거나 인터넷에서 전송되어 온 메일을 읽을 수도 있기 때문에 공격자는 함정으로 유도하여 인트라넷을 공격할 수 있게 됩니다.

### XSS 크로스 사이트 스크립팅
- 취약성이 있는 웹 사이트를 방문한 사용자의 브라우저에서 부정한 HTML 태그나 JavaScript 등을 동작시키는 공격
- 폼에 함정을 설치하는 것 외에 유저의 쿠키를 빼앗을 수도공격자가 어떤 벙법으 있다.

### HTTP 헤더 인젝션
- 공격자가 리스폰스 헤더 필드에 개행 문자 등을 삽입함으로 임의의 리스폰드 헤더 필드나 바디를 추가하는 수동적인 공격
- 

### 메일 헤더 인젝션
- 웹 애플리케이션의 메일 송신 기능에 공격자가 임의의 To 및 Subject 사이트등의 메일 헤더를 부정하게 추가하는 공격이다.
- 취약성이 있는 웹 사이트를 이용해서 스팸 메일이나 바이러스 메일 등을 임의의 주소에 송신할 수 있다.

### 디렉토리 접근 공격
- 디렉토리 파일에 대해 부정하게 디렉토리 패스를 가로질러 액세스 하는 공격
- 패스 트레버셩이라고도 함

### 리모트 파일 인클루젼
- 스크립트 일부를 다른 파일에서 읽어올 때 공격자가 지정한 외부 서버의 URL을 파일에서 읽게 함으로써 임으의 스크립트를 동작시키는 공격

## 웹 서버의 설정이나 설계 미비로 인한 취약성
### 강제 브라우징
- 웹 서버의 공개 디렉토리에 있는 파일 중에서 공개 의도가 없는 파일이 열람되게 되는 취약성
### 부적절한 에러 메세지 처리 
- 공격자에게 유익한 정보가 웹 애플리케이션의 에러 메세지에 포함된다는 취약성이다.
### 오픈 리다이렉트
- 지정한 임의의 URL로 리다이렉트 하는 기능
- 리다이렉트되는 곳의 URL에 악의가 있는 웹 사이트가 지정된 경우 유저가 그 웹 사이트로 유도되는 취약성과 연결된다.

## 세션관리 미비
- 세션 하이젝 - 공격자가 어떤 방법으로 유저의 세선 ID를 입수해서 악용하는 것, 유저로 위장하는 공격
- 세션 픽세이션 - 공격자가 지정한 유저 ID를 강제적으로 사용하게 함
- 크로스사이트 리퀘스트 포저리 CSRF - 인증된 유저가 의도하지 않은 개인 정보나 설정 정보 등을 공격자가 설치해둔 함정에 의해 어떤 상태를 갱신하는 처리를 강제로 실행시키는 공격으로 수동적 이다.