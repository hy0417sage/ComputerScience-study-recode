# 코틀린 기본 정리

## 코틀린에서 변수를 다루는 법
- 모든 변수는 var/val을 붙여 주어야 한다.
    - val : 변경 불가능하다. / var : 변경 가능하다.
- 타입을 명시적으로 작성하지 않아도, 타입이 추론된다.
- primitive type과 reference type을 구분하지 않아도 된다.
- null이 들어갈 수 있는 변수는 타입 뒤에 ?를 붙여준다.
- 객체를 인스턴스화 할 때 new를 붙이지 않아야 한다.

### 원시타입과 참조타입
- 코틀린은 모든 변수가 참조변수이다.
- 프로그래머가 boxing / unboxing을 고려하지 않도록 Kotlin이 알아서 처리해준다.

## 변수와 상수
- val (variable) : 상수 값 선언
- var : 변수 값 선언

### 기본 자료형
- 기본 자료형 Primitive data type : 순수하게 값을 저장하는 자료형
- 참조 자료형 Reference data type : 객체를 만들고 객체의 참조값을 저장한다.
- **코틀린의 자료형은 모두 참조 자료형!!** 모든 자료형이 객체 형태이다. 

#### 코틀린 정수 자료형 : Byte, Short, Int, Long
- Byte (1 Byte)
- Short (2 Byte)
- Int (3 Byte)
- Long (8 Byte)

#### 코틀린의 실수 자료형 : Double, Float
- Double (8 Byte)
- Float (4 Byte) 
- 자료형을 명시하지 않으면 Double형
- Float 형으로 지정하고 싶다면 값뒤에 f

#### 논리 자료형 : Char, String
- Char = 'H' //문자 하나
- String = 'Hi Hello' // 문자열

#### 배열 자료형 : arrayOf()
- val stringArray = arrayOf("apple", "banana", "grape")
 
#### 명시적 형 변환 : toString(), toDouble()

## 코틀린 제어문
- 직관젹이고 간결한 제어문을 제공한다.
- for, while, if, when

### 범위 클래스 
- : IntRange
- : CharRange
- val charRange : CharRange = 'a'..'e'

### for 문
- in 연산자와 함께 사용할 수 있음
- for(i in 1..5 step 2) //중위 연산자 step 사용
- for(i in 1...5 downTo 1)
- for((index, name) in student.withIndex())

### while 문
- 주어진 조건이 참일 때 계속 반복하는 제어문
- while(num < 5)

### if 문
- if(num > 8)

### when 문
- 코틀린은 switch 문이 없음. when 문이 있음.
- when(essayScore) {
    in 0..40 -> "D"
    else -> "A"
} 

## 09. 코틀린에서 클래스를 다루는 방법
1. 클래스와 프로퍼티
    - 코틀린에서는 필드만 만들면 getter와 setter는 자동으로 만들어 준다.
    - 코틀린에서는 생성자를 만들어 줄 때 동시에 프로퍼티(필드 setter/getter)를 선언할 수 있다.
2. 생성자와 init
3. 커스텀 getter, setter
4. backing field

## 컬렉션 : List, Set, Map

### List : listOf(), mutableListOf()
- 순서가 있는 자료구조
- 읽기, 쓰기 전용 리스트 만들 수 있음
~~~kotlin
val numImmutableList = listOf(1, 2, 3)
numImmutableList[0] = 1 //오류 발생
~~~
~~~kotlin
val numMutableList = mutableListOf(1, 2, 3)
numMutableList[0] = 100
~~~

### Set : setOf(), mutableSettOf
- 순서가 없는 자료구조
- 중족되지 않는 요소들로 만들어 짐
~~~kotlin
val immutable = setOf(1, 1, 2, 2, 3, 3, 3, 4) // 1, 2, 3, 4
~~~

### Map : mapOf(), mutableMapOf()
- 키와 값을 짝지어 저장하는 자료구조
- 키는 중복되지 않아야 함

## 함수 vs 메서드
- 함수 : 어떠한 기능을 수행하는 코드 형식
- 메서드 : 클래스 안에 선언된 함수

## 클래스의 생성자
- 객체를 생성할 때 항상 실행되는 특수한 함수로 **객체 초기화가 목적**
- 주생성자(primary constructor)와 보조 생성자(secondary constructor)가 있음

### 주 생성자
- 클래스 이름 옆에 괄호로 둘러쌓인 코드를 주 생성자라고 함 (constructer 생략 가능)
- class Person(name : String){}

### 보조 생성자
- 클래스 바디 내부에서 constructor 키워드를 이용해 만들며, 객체 생성시 실행할 코드를 작성해 넣을 수 있다.
- 주 생성자가 존재할 때 반드시 this 키워드를 통해 주 생성자를 호출해야 한다.

### 초기화 블록
- 객체 생성시 필요한 작업을 하는 것이 초기화 블록이다.
- init{} 안의 코드들은 객체 생성 시 가장 먼저 실행되고 주 생성자의 매개변수를 사용할 수 있다.
- 주로 주 생성자와 같이 쓰인다.

## 클래스의 상속
- 코틀린에서 상속을 받으려면 부모 클래스에서 open 키워드를 추가해야 한다.
- 메서드도 자식 클래스에서 오버라이드 하려면 부모 클래스의 메서드에 open 키워드를 추가해야함

## 접근 제한자
- 누구에게 클래스의 메서드와 변수를 공개할 것인가?
### public 
- 코틀린의 기본 접근 제한자. 어디서나 접근 가능
### internal 
- 같은 모듈 내에서 접근 가능. 
- 안드로이드 개발 시에는 한 프로젝트 안에 있으면 같은 모듈이라고 보면 됨
- 만약 한 프로젝트에 여러 모듈을 만든다면 이는 모듈간의 접근이 제한됨
### protected
- 자식 클래스에서는 접근할 수 있음
### private
- 해당 클래스 내부에서만 접근할 수 있음

## companion 키워드
- 자바에서는 static 키워드를 이용하면 정의된 변수나 메서드들은 객체를 만들지 않고도 접근이 가능
- 코틀린에서는 companion 키워드가 그 역할

## 추상 클래스
- 추상 클래스란 그 자체로는 객체를 만들 수 없는 클래스로 일반적으로 추상 메서드가 포함된 클래스를 말한다.
- 추상 메서드란 아직 구현되지 않고 추상적으로만 존재하는 메서드를 말한다.
- 추상 클래스와 추상 메서드 앞에 abstract 키워드를 붙인다.
- 상속받은 자식 클래스에 특정 메소드를 강제 구현하고 싶을 때 사용
- 추상 클래스 자체로는 직접 객체를 만들 수 없고 자식 클래스에서 추상 메서드를 구현한 다음, 자식 클래스를 생성하면 된다.

## 데이터 클래스
- 코틀린의 데이터 클래스는 특정한 메서드 실행 보다는 데이터 전달에 목적이 있다.
- 코틀린은 데이터 전달용 객체를 간편하게 생성하도록 data class라는 키워드를 제공한다.

## 인터페이스
- 클래스들이 같은 기능을 수행하게끔 강제한다.
- 예를 들면 자동차 인터페이스 경우, 최소한 가고, 멈추는 기능을 추상 메서드로 만들어야 한다.
- 추상 메서드임을 선언하는 키워드 abstract 는 추상 클래스에서는 필요하나 인터페이스에선 생략할 수 있다.

## 디폴트 메서드
- 코틀린도 자바처럼 인터페이스에서 기본적으로 구현하는 메소드를 제공할 수 있다.
- 해당 인터페이스들을 구현하는 클래스들은 디폴트 메서드 만큼은 오버라이드 하지 않아도 된다. (필요시 해도 됨)

## Null 처리하기
- 자바에서는 객체가 반환하는 함수가 반환할 객체가 없을 때 null을 반환한다.
- 이 방식은 null 체크가 필요하다
- 안그러면 NPE을 만나게 된다. 이걸 코틀린이 해결!!!

### Nullable 과 Non-Nullalbe
- 코틀린은 기본적으로 '객체는 null 이 될 수 없다.'고 본다.
- 따라서, 모든 객체들은 생성괴 동시에 초기화 해야 한다.

### 셰이프 콜 연산자 ?
- ? 연산자를 이용하면 메서드 호출, 혹은 객체 프로퍼티 접근과 null체크를 한번에 할 수 있다.
- ? 연산자를 셰이프 콜 연산자(안전 호출 연산자)하며
- 만약 객체가 참조가 null이면 셰이프 콜 연산자의 반환값음 null이 된다.

### 엘비스 연산자 ?:
- 엘비스 연산자는 ? 연산자를 이용해 셰이프콜을 할 시 null을 반환하지 않고, 기본값을 반환한다.

### 확정 연산자 !!
- 절대 null을 아님을 보증하는 연산자.
- 이게 null이 가능한 자료형이긴 한데, 정대 null 이 아니니 걱정마!

## lateinit 키워드와 lazy 키워드
- lateinit은 var로 선언한 변수의 늦은 초기화를 돕고
- lazy는 val로 선언한 상수의 늦은 초기화를 돕는다.

### lateinit 키워드
- 코틀린에서는 기본적으로 모든 변수는 null 아니기 떄문에 선언과 동시에 처기화 되어애 한다.
- 만약 변수 값을 나중에 넣고 싶다면 lateinit 사용
- lateinit 키워드를 사용하면 일단 변수를 선언하고 나중에 값을 할당할 수 있음

### lateinit 을 사용할 때 주의할 점
1. var 변수에서만 사용
2. nullabe 자료형과 함께 사용할 수 없음
3. 초기화 전에 변수를 사용하면 에러가 발생
4. 원시 자료형(Int, Double, Float) 등에는 사용이 불가능
5. **::변수명.isInitialized()** 함수로 함수가 초기화 되었는지 확인할 수 있음

### lazy 키워드
- lazy 키워드를 이용하면 변경할 수 없는 병수인 val의 늦은 초기화를 할 수 있다.
- 객체가 생성될 때 초기화 하는 것이 아니라 처음 호출 될 때 lazy{} 안의 코드가 실행되면서 초기화 됨

## 람다식 "람다식은 마치 값처럼 다룰 수 있는 익명 함수다."
- 람다 표현식, 람다라고 불림
- 람다식을 값처럼 다룰 수 있다는 말은, 람다식 자체가 함수의 인수가 되거나 변환값이 될 수 있다는 말과 같다.

## Single Abstract Method (SAM)
- 람다식이 아닌데도 람다식으로 취급
1. 코틀린 인터페이스가 아닌 자바 인터페이스여야 할 것
2. 인터페이스 내에는 딱 한 개의 추상 메서드만이 존재할 것
- 위와 같은 조건을 만족하는 경우 익명 인터페이스 객체 생성에 람다식을 사용할 수 있음




# lazy initalization 지연 초기화
- 객체의 일부분을 초기화 하지 않고 남겨 뒀다가 실제로 그 부분의 값이 필요할 경우 초기화 할 때 쓰이는 패턴이다.
- 초기화 과정에 자원을 많이 사용하거나 객체를 사용할 때마다 꼭 초기화 하지 않아도 되는 프로퍼티에 대해 지연 초기화 패턴을 사용할 수 있다.

## 프로퍼티
- 필드와 접근자를 통칭 한다.
~~~koltin
class Person(val name: String, var isMarried: Boolean)
~~~

## lazy
- 데이터를 저장할 때 쓰이는 뒷받침하는 프로퍼티와 값이 오직 한 번만 초기화 됨을 보장한다.
- 데이터를 저장 할 때 쓰이는 뒷 받침하는 프로퍼티와 오직 한 번만 초기화됨을 보장하는 케터 로직을 함께 캡슐화 함
- 위임 객체를 반환하는 표준 라이브러리 함수
~~~Kotlin
    class Email{}
    fun loadEmails(person: Person) : List<Email>{
        println("${person.name}의 이메일을 가져옴")
        return listOf()
    }
~~~
### lazy를 쓰지 않고 지연 초기화를 할 경우
~~~Kotlin
class Person(val name: String){
    private var _emails : List<Email>? = null
    val emails: List<Email>
        get(){
            if(_email == null){
                _emails = loadEmails(this)
            }
        }

        return _emails!!
}
~~~
- 뒷받침 하는 프로퍼티 (여기선 _email) : 값을 저장하는 프로퍼티로 null이 될 수 있다.

### 지연 초기화를 위임 프로퍼티를 통해 구현하기 
~~~Kotlin
class Person(val name: String){
    val emails by lazy{ loadEmails(this) }
}
~~~
- lazy 함수는 코틀린 관례에 맞는 시그니처의 getValue 메서드가 들어있는 객체를 반환한다.
- 따라서 by 키워드와 함께 사용해 위임 프로퍼티를 만들 수 있다.
- lazy는 기본적으로 스레드 안전하다.
- 하지만 필요에 따라 동기화에 사용할 락을 lazy함수에 전달할 수 있고, 다중 스레드 환경에서 사용하지 않을 프로퍼티를 위해 lazy함수가 동기화 하지 못하게 막을 수 있다.



# 코틸린 타입 시스템 : Nullable Type(널이 될 수 있는 타입)

## nullability (널 가능성)
- 널 가능성은 NPE 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성!
- 코틀린은 null이 될수 있는 타입을 명시적으로 지원한다.
    - 모든 타입은 기본적으로 널이 될 수 없는 타입
    - 뒤에 ?가 붙어야 널이 될 수 있다.
- Null 가능성이 있는 타입일 경우 
    1. 메서드 직접 호출 제한
    2. 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없음
- nullability 여부를 미리 판단해서 컴파일시 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

## 타입의 의미
- 타입은 어떤 값들이 가능한 지와 
- 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.
- String와 Null타입은 서로 완전히 다르다.
    - 두 종류의 값에 대해 실행할 수 있는 연산도 완전히 다름
- 코틀린의 Null이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.

# 코틀린이 제공하는 null이 될 수 있는 값을 다룰 때 도움이 되는 도구
1. 안전한 호출 연산자 .?
2. 앨비스 연산자 ?:
3. 안전한 캐스트 as?
4. 널 아님 단언 !!
5. let 함수

## safe call 연산자 (안전한 호출 연산자 .?)
- **null 검사**와 **메서드 호출**을 한번의 연산으로 수행한다.
- 메서드 호출 시 호출하려는 값이 null 이면 호출은 무시되고 null이 결과 값이 됨, null 이 아니라면 일반 메서드 호출처럼 작동
- 메서드 호출 뿐만이 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있음

## 앨비스 연산자 ?:
- null 대신 사용할 디폴트 값을 정할 때 사용할 수 있는 연산자
- 앨비스 연산자의 좌항이 null 이면 즉시 어떤 값을 반환하거나 예외를 던진다.
- (+) 함수의 전제 조건을 검사하는 경우 특히 유용

## 안전한 캐스트 as?
- 연산자의 어떤 값을 지정한 타입으로 캐스트 한다.
- 값을 대상 타입으로 변환할 수 없으면 null을 반환한다.
- 파라미터로 받은 값이 원하는 타입인지 쉽게 검사하고 캐스크 할 수 있다.
    - 여기서 잠깐! is와 비교
    - (조건문 안에서 사용) is가 포함된 조건문 안의 코드는 전부 다운 캐스팅이 적용된다. 
    - 조건문 뿐만 아니라, 전체적인 코드에 다운캐스팅을 적용할 수 있음

## 널 아님 단언(not-null assertion)
- 어떤 값이든 널이 될 수 없는 타입으로 강제로 바꿀 수 있음
- 실제 널에 대해 !!를 적용하면 NPE가 발생
- (+) ...무엇일까요

### 스택 트레이스 (stack trace)
- 프로그램이 시작된 시점 부터 현재 위치 까지의 메서드 호출 목록
- 예외가 어디서 발생 했는지 알려주기 위해 JVM이 자동으로 생성 

## let 함수
- 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 값으로 바꿔서 람다에 전달
- let 함수는 null이 아닌 경우에만 호출됨
- 널이 될 수 있는 식을 더 쉽게 다룰 수 있음



# 02 객체 표현과 주석

### 리터럴
- 리터럴이란 하나의 값을 말하며 보통 숫자, 문자 문자열이다.
- 클래스를 만들어 객체로 만든 값은 모두 리터럴이다.

### 객체 
- 객체란 클래스에 의해 생성되는 모든것을 말한다.
- 보통 숫자, 문자열 등은 리터럴 표기법으로 객체를 만들지만, 사용자가 class 예약어로 정의한 리터럴 표기법으로 객체를 표현할 수 없다.

### 정수와 실수도 객체이다. / 문자, 문자열, 논릿값도 객체이다.
- 코틀린에서는 정수와 실수도 다양한 클래스로 구분한다.
- 세분화하여 구분하는 이유는 코틀린에서는 각 클래스의 자료형을 별도로 관리하기 때문이다.
~~~kotlin
intVar.javaClass.lotlin
longVar.javaClass.lotlin
doubleVar.javaClass.lotlin
floatVar.javaClass.lotlin
~~~

### 겍체는 메서드로 연산을 수행한다.
- 모든 객체는 상태(속성)와 행위(메서드)를 가진다. 
- 그래서 정수와 실수도 객체이므로 속성과 메서드를 가지고 있다.
- 보통 숫자 객체는 변경할 수 없는 객체이므로 연산자를 수행하면 새로운 객체를 생성한다.
    - 메서드 : 클래스 내부에 정의한 함수로 객체가 점 연산자로 접근해서 실행할 수 있다.


### 변수와 상수
- val (불변변수) : 한번 저장하면 다시 할당할 수 없는 변수를 정의한다.
- var (가변변수) : 재할당할 수 있는 변수를 정의한다.

### 변수 상수 정의와 참조 구분
- 정의 : 변수와 상수를 처음으로 만드는 것을 말한다.
- 참조 : 만들어진 변수나 상수의 값을 이름으로 조회하는 것을 말한다.
- 할당 : 변수나 상수에 초깃값을 지정하는 것을 말하며, 재할당은 변수의 값을 바꾸는 것을 말한다.

### 식별자 이름 작성
- 식별자란 변수, 함수, 클래스 등을 이름으로 구별해서 참조하는 모든 것을 말한다.
- 카멜 표기법 : 메서드 명으로 사용, 첫 글자는 소문자 다음 단어의 첫글자는 대문자
- 파스칼 표기법 : 단어들의 첫글자를 대문자로 쓴다.
- 스네이크 표기법 : xml에서 많이 사용

### 사칙연산자 처리
- 사칙연산자는 두 개의 **오퍼랜드** 즉, 두 개의 항으로 덧셈, 뺄셈, 나눗셈, 곱셈 등을 처리하는 연산자이다.

### 연산자를 추가로 사용하는 경우
- 문자와 리스트에 + - 연산자 사용가능

### 표준 입출력
- 입출력 함수 : readline
- 출력 함수 : print, println
- 특정 문자열을 쪼개는 split 메서드 : 분리하는 문자열을 기준으로 세부 문자열을 분리해서 리스트로 반환한다.
- 모든 원소를 반환하는 map 메서드 : 여러 원소를 가진 컬렉션 자료형의 개변 원소를 받아 내부적으로 순환하면서 변환 처리한다.

### ✨ 동등성과 동일성
- 동등성(==) : 동일한 값을 비교할 경우
- 동등성(===) : 동일한 객체를 가리키는 경우, 동일한 정수는 유일하고 레퍼런스도 같으므로 참으로 표시한다.
~~~kotlin
val a = 100
val b = 100

println(a == b) //값이 동일하여 true
println(a === b) // 100이라는 정수의 값은 유일하므로 true
~~~

### ✨ 함수도 일급 객체
- 함수도 정의되면 하나의 객체가 만들어 진다.
- 그래서 함수도 참조적 동등성을 비교할 수 있다.
    - 함수 참조 : 함수 정의 후에 메모리에 로딩된 함수의 주소를 가져오는 리플렉션 기능이다.
    - hashcode 메서드 : 레퍼런스를 정수로 변환해주는 메서드이다.
- 함수도 객체이므로 레퍼런스를 가질 수 있다. 변수에 할당하려면 함수 참조를 사용해서 함수 레퍼런스를 가져올 수 있다. 또한, 해시코드로 변환하면 정수로 표시되어 쉽게 비교할 수 있다.

### 내포된 순환 처리
- 순환문 내부에 내포된 순환문이 있을 경우 전체 순환을 종료하려면 레이블을 사용해서 외부 순환문까지 빠져나올 수 있도록 처리한다.
- 이때 순환문 앞에 (레이블명 + @) 를 붙이고 (break + @) 레이블명을 지정한다.
~~~kotlin
loop@ for(i in 1..3){
    for(j in 1..5){
        if(j==3){
            println("내포순환")
            break@loop
        }
        println("for 순환 $ㅓ")
    }
}
~~~

### 범위 반복자 iterator
- 여러개의 원소를 가진 자료형인 범위, 배열, 리스트 등은 반복형 클래스이며, 이를 객체로 만들어도 반복형 객체이다. 이 반복형을 iterator 메서드로 반복자 클래스의 객체로 변환할 수 있다. 반복형과 반복자의 차이점은 반복형을 반복자로 자료형을 반환하면 내부의 원소를 순환할 수 있는 메서드가 추가된다.
~~~kotlin
var 1..10
val ilter = i.iterator()
ilter.forEach { print(it.toString() + ",") } //내부 순환
~~~