# FLow
- 코루틴의 Flow는 데이터 스트림이며, 코루틴 상에서 리액티브 프로그래밍 지원하기 위한 구성 요소이다.

## 리액티브 프로그래밍
- 리액티브 프로그래밍이란 데이터가 변경 될 때 이벤트를 발생시켜서 데이터를 계속해서 전달하도록 하는 프로그래밍 방식
- 기존 명령형 프로그래밍에서는 데이터의 소비자가 데이터를 요청한 후 받은 결과 값을 일회성으로 수신한다. 
  - 이러한 방식은, 데이터가 필요할 때마다 결과값을 매번 요청해야한다 (매우 비효율적)
- 리액티브 프로그래밍에서는 데이터를 발행하는 발행자가 있고 데이터의 소비자는 데이터의 발행자에 구독 요청을 한다.
- 그러면 데이터의 발행자는 새로운 데이터가 들어오면 데이터의 소비자에게 지속적으로 발행한다.
- **데이터 스트림** - **리액티브 프로그래밍에는 하나의 데이터를 발행하는 발행자가 있고 해당 발행자는 데이터의 소비자에게 지속적으로 데이터를 전달하는 역할을 한다.**

## 코루틴 플로우를 이용한 리액티브 프로그래밍
- 코루틴 플로우는 코루틴 상에서 리액티브 프로그래밍을 지원하기 위해 만들어진 구현체이다.
- 코루틴에서 데이터 스트림을 구현하기 위해서는 Flow를 사용해야 한다.

# 데이터 스트림의 구성요소
- 생산자
- 중간 연산자
- 소비자

## 생산자 Producer
- 먼저 생산자는 데이터를 발행하는 역할을 한다.
- Flow 에서의 Producer는 **flow{} 블록 내부**에서의 **emit() 을 통해 데이터를 생성**한다.

### 안드로이드 상에서 생산자가 가져오는 데이터의 대표적인 DataSource는 두가지이다.
1. 서버의 데이터로 보통 REST API 를 이용해 가져오는 데이터
2. 휴대폰 상의 DB에서 가져오는 데이터

### 과정
1. 먼저 flow 블록을 선언한다.
2. 데이터를 서버로부터 받아온다.
3. 생산자(producer)가 데이터를 생성한다. (emit)
4. 2~3 과정을 60초마다 반복하며 데이터를 계속해서 생성한다.

## 중간 연산자 Intermediary
- 생산자가 데이터를 생성했으면 중간 연산자는 생성된 데이터를 수정한다.
- 대표적인 중간 연산자는 map(데이터 변형), filter(데이터 필터링), onEach(모든 데이터마다 연산 수행) 등의 중간 연산자가 있다.

## 소비자 Consumer
- 중간 연산자가 생산자가 생성한 데이터를 변환하여 소비자로 데이터를 전달한다.
- FLow에서는 collect를 이용해 전달된 데이터를 소비할 수 있다.
- 안드로이드 상에서 데이터의 소비자는 보통 UI 구성요소이기 때문에, UI는 데이터를 소비하여 데이터에 맞게 UI를 그려낸다.
- 우리는 받은 미세먼지 데이터를 이용해 ViewModel에서 필요한 처리를 하여 View 에서 사용하면 된다.

---

# Flow와 StateFlow의 차이
- Flow는 데이터의 흐름이다. 
- 데이터의 흐름을 발생시키기만 할 뿐 데이터가 저장되지 않는다.
- 따라서 flow만을 이용해 안드로이드의 UIState를 업데이트 하기 위해서는 두가지 방법이 가능했다.
  - 1. 화면이 재구성 될 때마다 다시 서버 혹은 DB로 부터 데이터 가져오기
  - 2. Flow로부터 collect한 데이터를 ViewModel에 저장해 좋고 사용하기

### 1. 화면이 재구성 될 때마다 다시 서버 혹은 DB로 부터 데이터 가져오기
- 이 방법은 비효율적이다. 안드로이드에서는 화면이 회전되었을 때마다 onDestroy가 호출된 후 다시 onCreate이 호출되는데, 이때마다 새로운 데이터를 서버 혹은 DB로부터 가져와야 하기 때문이다.

### 2. Flow로부터 collect한 데이터를 ViewModel에 저장해 좋고 사용하기
- ViewModel은 onDestory가 호출되더라도 살아있고 ViewModel에서 해당 데이터를 저장하고 있으면 되기 때문이다.
- 하지만 2번 방법에서 데이터를 저장하고 있으려면 별도의 데이터 홀더 변수를 만들어야 한다.
- 또한 데이터 홀더 변수는 Reactive 하지 않기 때문에 UI에서 데이터 홀더 변수를 구독하기 위해서는 별도의 fetching 로직을 만들어야 한다.
  - *fetching 로직 - 데이터를 가져오는 로직
- 이는 보일러 플레이트 코드를 만들어 낸다. 안드로이드에서 수집하는 UIState(UI를 위한 데이터)가 한 두개가 아닌데 모두를 구독하기 위해서 비슷한 코드를 매번 작성해 가독성을 떨어트리는 것은 지양해야 한다.
  - *보일러 플레이트 : 비슷한 코드가 반복되는 것

#### 위와 같은 문제를 해결하기 위해 StateFlow가 등장

## StateFlow의 등장
- StateFlow는 데이터 홀더(저장소) 역할을 하면서 FLow의 데이터 스트림 역할까지 한다.
- UI 단에서 StateFlow를 구독해 UIState(UI를 위한 데이터)를 업데이트 하면 **화면이 재구성 될 때마다 다시 서버로 데이터를 요청할 필요가 없어진다.**

#### 하나의 만들어진 FLow 는 UI에서 사용하기 위해 StateFlow로 변환되어야 한다. 이 UI에서는 이 StateFlow를 구독하여 항상 최신 데이터를 발행받는다.
- 이것이 가능하기 위해서는 FLow를 StateFlow로 변환하는 로직이 필요하다. 또한 StateFlow가 항상 Flow를 구독하고 있으면 메모리 누수가 생기므로 이 StateFlow가 살아있어야 하는 CoroutineScope을 명시할 수 있어야 한다. 
- 이를 stateln 함수를 통해 할 수 있다.
- StateFlow는 Cold Stream이 아니라 Hot Stream이다. 마지막 홀당히고 있는 데이터를 구독하는 구독자에게 전달할 뿐, 구독자가 구독할 때 발행을 위한 로직을 Trigger 하지는 않는다.

## stateln 함수를 사용하면 Flow를 StateFlow로 변환하기
- stateln은 세 가지 변수를 받는다.
- scope : StateFlow 가 Flow로 부터 데이터를 구독받을 CoroutineScope을 명시한다.
- started : Flow로 부터 언제부터 구독을 할 지 명시할 수 있다.
- initialValue : StateFlow에 저장될 초기값을 설정한다. 
