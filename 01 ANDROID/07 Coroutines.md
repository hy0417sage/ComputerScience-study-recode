🖐🏻코루틴은 비동기적인 코드를 동기적으로 작성할 수 있도록 도와주는 기능입니다. '일시 중단이 가능한 경량 스레드'라고 불리는 코루틴에 대해서 같이 공부해봅시다.


## 먼저 알고 넘어가기
### 인터럽트
CPU 작업을 방해하는 신호를 인터럽트라고 합니다.
작업이 실행되고 있을 때, 입출력 하드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요한 상황을 CPU에게 알려 해당 작업을 잠시 중단 시킵니다.

### Context Switching
Context Switching이란 OS 스케줄러가 다중 작업 환경에서 CPU 자원을 효율적으로 사용하기 위해 현재 작업에서 다른 작업으로 실행 흐름을 전환하는 것을 의미합니다. 인터럽트를 발생 시켜서 CPU에서 실행중인 작업을 중단 하고, 다른 작업을 처리합니다.
중단 시에는 현재 실행 중인 작업의 상태(Context)를 먼저 저장하고, 다음 인터럽트로 들어온 작업을 처리한 후에 이전에 저장된 작업의 상태를 다시 복구합니다.

## 코루틴이란?
코루틴이란 비동기적인 코드를 동기적으로 작성할 수 있도록 도와주는 기능으로, 일시중단이 가능한 경량 스레드라고 불립니다.
 
#### 일시중단이 가능한 보통 경량 스레드? 이게 도대체 무슨 말..?
경량 스레드에 대한 개념을 이해하기 전 코루틴이 나오게 된 배경을 먼저 알아볼까요?

## 더 나은 비동기 처리 방식의 필요성
코루틴이 나오게 된 배경은 더 나은 비동기 처리 방식의 필요성 때문입니다.
코루틴이 나오기 전 스레드만 사용했을 경우 어떤 문제가 있었을까요?
- 콜백 지옥 문제
    이전에는 비동기적인 작업을 처리하기 위해 콜백 함수를 사용하는 방식이 일반적이었습니다. 하지만 콜백 함수를 중첩하여 사용하면 코드가 복잡해지고 가독성이 떨어지는 콜백 지옥 문제가 발생하게 되었습니다.
- 스레드 기반 비동기 처리의 한계 
    스레드를 이용한 비동기 처리는 비교적 쉽고 간단하게 구현할 수 있습니다. 하지만 스레드를 많이 사용하면 메모리 부족과 스레드 간의 경합이 발생하여 성능이 저하되는 문제가 발생합니다. 또한, 스레드 간의 공유 자원에 대한 동기화 문제도 발생할 수 있습니다.

### 이 글에선 기존 스레드의 한계점에 대해 말해보며 코루틴을 이해해보겠습니다.
#### 기존 스레드의 한계점
- 코루틴 대비 Thread는 상대적으로 생성 비용이 비싸고 작업을 전환하는 비용이 비쌉니다. 또한 한 Thread가 다른 Thread부터의 작업을 기다려야 할 때 블로킹 되게 되면 해당 Thread는 하는 작업 없이 다른 작업이 끝나쳐 질 때까지 기다려야 하기 때문에 자원은 낭비됩니다.
![](https://blog.kakaocdn.net/dn/cbGV3s/btr6bt39l0q/ETnKpvlP7IA1DnAhRgeNlk/img.png)

- 위의 작업을 보면 Thread2에서 Task1 작업을 하다가 Task2의 자원이 필요합니다. 그럼 Task1의 작업을 멈추고(Blocking) Thread3의 Task2 작업을 기다립니다. Thread3의 Task2의 작업이 끝났다면, 다시 Thread2의 Task1을 재개합니다.
 
여기서 포인트는 Thread2는 Blocking된 후 Thread3의 작업이 끝날 때까지 계속 기다려야합니다. Task1의 작업이 끝나지 않아 다른 일을 할 수 없기 때문입니다. 그럼 스레드가 생성되어 있지만 사용하고 있지 않는 상태에 놓입니다.

##### > Thread는 생성 비용이 비싸고 작업을 전환하는 비용이 비싸다의 추가적인 설명
1. 생성 비용이 비싸다.
    - Thread를 생성하는 데는 일정한 시간이 소요됩니다. 이는 스레드의 상태, 메모리 할당, 초기화 및 스케줄링 작업 등을 포함합니다. 따라서 Thread 생성 비용이 높습니다.
2. 전환 비용이 비싸다. 
    - 쓰레드의 작업을 전환하는 비용은 쓰레드 상태를 저장하고 복원하는 데 필요한 시간과 자원이 소비되는 것을 말합니다. 이러한 작업 전환 비용은 CPU 자원과 메모리 자원 등의 자원을 소비하며, 적절한 관리가 이루어지지 않으면 성능 저하의 원인이 될 수 있습니다.

## 이제 코루틴을 봐볼까요?
코루틴은 쓰레드 위에서 동작합니다.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpqmoQ%2Fbtr6os5F19G%2Fd6Vmdd1HiUypScLlz6QAP0%2Fimg.png)
Thread2의 Coroutines1에서 Task1을 작업하는 중간에 Thread3의 Coroutines1에서 실행되고 있는 Task2의 작업의 결과가 필요합니다. 그럼 Task1을 잠시 멈추고 Thread2의 Coroutines2에서 일단 다른 작업을 실행합니다. Thread3의 Coroutines1이 작업하는 Task2의 작업이 끝났고, Thread2의 Coroutines2에서 Task3의 작업이 끝났다면, Task2의 결과를 전달받아 Task1은 재시작 됩니다.
 
위처럼 코루틴은 쓰레드가 진행하던 작업이 일시정지 되더라도 이 상태로 블로킹되지 않고 다른 작업을 진행할 수 있습니다. 스레드의 생성을 줄이고 기존 스레드의 자원을 사용할 수 있죠. 이 부분에서 코투린이 논블로킹(일시정지)가 가능한 경량 스레드라고 불리는 이유가 됩니다.

### 그럼 여기서 또 궁금한 점이 생깁니다.
지금 동작하고 있는 Task3의 작업 시간이 길어지면 어떻게 되는걸까? Task3이 길어지니 Thread3의 또 다른 Coroutines2 작업을 시작하게 될꺼고 이러한 과정을 여러번 거치다 보면 오랜 시간이 지나야지만 Task1이 재개될 수 있는것 아닐까? 🤔
- 제가 내린 결론은 'Task3이 길어지는 건 어쩔 수 없다'입니다. 개발자 입장에선 CPU 자원을 효율적으로 사용하는게 좋기 때문에 스레드 자체가 블로킹이 되는것이 아니라면 생성이나 전환에서 비용을 줄일 수 있기 때문에 감수할 수 있다는 것이죠. 하지만 이게 모든 상황에 적용된다고 생각하지 않습니다. 비동기처리를 무조건 코루틴을 사용하는 것이 아니라 상황에 따라 스레드와 코루틴을 같이 사용하는 것이 방법이 될 것 같습니다.

## 정리
- Tread를 하나를 일시 중단 가능한 다중 경량 스레드처럼 활용하는 것이 코루틴이다.
- 하나의 쓰레드에 여러 코루틴이 존재할 수 있다.
- 코루틴이 경량 스레드로 불리는 이유는 스레드의 경우 컨텍스트 스위칭을 할 때 스레드 생성 비용이 든다. 반면 코루틴은 스레드 위에서 돌기 때문에 CPU 동작 비용을 아낄 수 있다.

---

# 코루틴의 상태 관리
- launch 는 코루틴 실행, 상태 관리를 할 때에 사용된다.
- async 는 코루틴 실행, 상태 관리와 더불어서 결과도 반환 받을 수 있다.
