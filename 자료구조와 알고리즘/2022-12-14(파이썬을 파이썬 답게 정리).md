# 파이썬을 파이썬 답게 정리

### for 문과 if문을 한번에 - List comprehension의 if 문
- list comprehension 안에서 조건문을 넣는 방법
~~~python
mylist = [3, 2, 6, 7]
answer = [number**2 for number in mylist if number % 2 == 0]
~~~

### 목과 나머지 - divmod
- 정수를 나눈 몫과 나머지를 구해야 할 때
~~~python
a = 7
b = 5
print(*divmod(a, b))
~~~
- 하지만, 작은 숫자를 다룰 때는 a//b, a%b 보다 느리다. 
- 큰 숫자를 다룰 때 사용하면 좋다!

### n진법으로 표기된 string을 10진법 숫자로 변환하기 - int함수
- 파이썬에서 int(x, base = 10) 함수는 진법 변환을 지원한다.
- 이 기본적인 함수를 잘 쓰면 코드를 짧게 쓸 수 있고, 또 시간을 절약할 수 있다.
~~~python
num = '3212'
base = 5
answer = int(num, base)
~~~

### 문자열 정렬하기 - ljust, center, rjust
- 문자열의 앞을 빈 문자열로 채워야 할 경우
- ljust, center, rjust와 같은 string의 메소드를 사용해 코드를 획기적으로 줄일 수 있다.
~~~python
s = '가나다라'
n = 7

s.ljust(n) # 좌측 정렬
s.center(n) # 가운데 정렬
s.rjust(n) # 우측 정렬
~~~

### 모든 대문자/소문자/대소문자/숫자를 가져오는 방법
- string 모듈을 사용하면 된다.
~~~python
import string 

string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz
string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ
string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
string.digits # 숫자 0123456789
~~~

### 원본을 유지한채, 정렬된 리스트 구하기 - sorted
- 반복문이나, deepcopy 함수를 사용하지 않아도 새로운 정렬된 리스트를 구할 수 있다.
~~~python
list1 = [3, 2, 5, 1]
list2 = sorted(list1)
~~~

### 모든 멤버의 type 변환하기 - map
- 파이썬의 map을 사용하면 for문을 사용하지 않고도 멤버의 타입을 일괄 변환할 수 있다.
~~~python
list1 = ['1', '2', '3']
list2 = list(map(int, list1))
~~~

### 2차원 리스트 뒤집기 - zip
- 파이썬의 zip과 unpacking 을 이용하면 코드 한 줄로 리스트를 뒤집을 수 있다.
~~~python
mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_list = list(map(list, zip(*mylist)))
~~~

### i번째 원소와 i+1번째 원소 - zip
- 파이썬의 zip을 이용하면 index를 사용하지 않고 각 원소에 접근할 수 있다.
~~~python
def solution(mylist):
    answer = []
    for number1, number2 in zip(mylist, mylist[1:]):
        answer.append(abs(number1 - number2))
    return answer

if __name__ == '__main__':
    mylist = [83, 48, 13, 4, 71, 11]    
    print(solution(mylist))
~~~

### sequence 멤버를 하나로 이어 붙이기 - join
- str.join()을 사용하면 두줄로 바꿀 수 있음
~~~python
my_list = ['1', '2', '3']
answer = ''.join(my_list)
~~~

### sequence type의 * 연산
- string, 배열 * 로 반복 가능
~~~python
n = 5
answer = 'abc' * n
~~~
- [123, 456, 123, 456, 123 ...] 과같이 123, 456이 n번 반복되는 리스트
~~~python
n = 5
answer = [123, 456] * n
~~~

### 곱집합 구하기 - itertools.product
- itertools.product를 이용하면, for 문을 사용하지 않고도 곱집합을 구할 수 있습니다.
~~~python
import itertools
iterable1 = 'ABCD'
iterable2 = 'xy'
iterable3 = '1234'
print(list(itertools.product(iterable1, iterable2, iterable3)))
~~~

### 2차원 리스트를 1차원 리스트로 만들기
- for 문을 사용하지 않고도 리스트를 이어 붙이기
~~~python
my_list = [[1, 2], [3, 4], [5, 6]]

# 방법 1 - sum 함수
answer = sum(my_list, [])
~~~

### 순열과 조합 - combinations, permutations
- 1,2,3의 숫자가 적힌 카드가 있을 때, 이 중 두 장을 꺼내는 경우의 수 -> 12, 13, 21, 23, 31, 32
- 'A', 'B', 'C'로 만들 수 있는 경우의 수 -> 'ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA'
~~~python
import itertools

pool = ['A', 'B', 'C']
print(list(map(''.join, itertools.permutations(pool)))) # 3개의 원소로 순열 만들기
print(list(map(''.join, itertools.permutations(pool, 2)))) # 2개의 원소로 순열 만들기
~~~

### 가장 많이 등장하는 알파벳 찾기 - Counter
- 알고리즘 문제를 풀다 보면 어떤 원소 x가 주어진 시퀀스타입에 몇 번이나 등장하는지 세야 할 때가 있다.
- 파이썬의 collections.Counter 클래스를 사용하면 이 코드를 간략하게 만들 수 있다.
~~~python
import collections
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 7, 9, 1, 2, 3, 3, 5, 2, 6, 8, 9, 0, 1, 1, 4, 7, 0]
answer = collections.Counter(my_list)

print(answer[1]) # = 4
print(answer[3])  # = 3
print(answer[100]) # = 0
~~~

### 이진 탐색하기 - binary search
- 파이썬의 bisect.bisect 메소드를 사용하면 이 코드를 간략하게 만들 수 있다.
~~~python
import bisect
mylist = [1, 2, 3, 7, 9, 11, 33]
print(bisect.bisect(mylist, 3))
~~~