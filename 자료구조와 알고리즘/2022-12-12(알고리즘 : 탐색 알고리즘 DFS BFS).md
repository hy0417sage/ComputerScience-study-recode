# 탐색 알고리즘 DFS/BFS

## ✅ 들어가기 전 알고가기
#### 그래프의 기본 구조
- 노드와 간선으로 표현되며, 이때 노드를 정점이라고 한다.
- 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다'라고 표현한다.

#### 그래프를 표현하는 두가지 방식
1. 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
~~~python
INF = 99999999 # 무한의 비용 선언

# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]

print(graph)
~~~
2. 인접 리스트 : 리스트로 그래프의 연결 관계로 표현하는 방식 
    - 인접 리스트는 '연결 리스트'의 자료구조를 이용해 구현하는데, C++이나 자바와 같은 프로그래밍 언어에서는 별도로 연결 리스트 기능을 위한 표준 라이브러리를 제공한다. 반면에 파이썬은 기본 자료형인 리스트 자료형이 append() 와 메소드를 제공하므로, 전통적인 프로그래밍 언어에서의 배열과 연결 리스트의 기능을 모두 제공한다. 
~~~python
# 행이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 오드 정보 저장(노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0, 5))

print(graph)
~~~
- 이 두가지 방식에는 메모리와 속도 측면에서 차이가 있다.

#### 인접 행렬과 인접 리스트의 차이점
- 인접 행렬은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다.
- 반면에 연결리스트는 연결된 정보만 저장하기 때문에 메모리를 효율적으로 사용한다. 하지만, 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. 인접리스트 방식에서는 데이터를 하나씩 확인해야 하기 때문이다.
    - 예시) 한 그래프에서 노드 1과 노드 7이 연결되어 있는 상황을 생각해 보자. 인접 행렬 방식에서는 graph[1][7]만 확인하면 된다. 반면에 인접 리스트 방식에서는 노드 1에대한 인접 리스트를 앞에서 부터 차례대로 확인해야 한다.
    - 그러므로 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.

## DFS 란?
- 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.
- 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘이다.

### 왜 사용하는 가?


### DFS의 동작 과정
- DFS는 스택 자료구조를 이용한다. 구체적인 동작 과정!
- 직관적으로 생각하면, 단순하게 가장 깊숙이 위치하는 노드에 닿을 때 까지 탐색하면 된다.
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최 상단 노드를 꺼낸다.
3. (2)번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.