# CPU 스케줄링 개요

### CPU 스케줄링을 사용하는 이유
- 운영체제가 프로세스들에 공정하고 합리적으로 CPU 자원을 배분하는 것을 "CPU 스케줄링"이라고 함
- 프로세스 마다 우선순위가 다르고 CPU 자원을 동시에 사용할 수 없기 때문에 중요함
- 대부분의 프로세스는 CPU와 입출력 장치를 모두 사용하여 실행된다
    - (=) 프로세스는 실행 상태와 대기 상태를 반복하며 실행된다.
    - 하지만! 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다!
    
## 입출력 집중 프로세스, CPU 집중 프로세스
- 입출력 집중 프로세스 : 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 된다.
- CPU 집중 프로세스 : 대기 상태보다는 실행 상태에 더 많이 머무른다.
- CPU 집중 프로세스와 입출력 집중 프로세스가 모두 동일한 빈도로 CPU를 사용하는 것은 비 합리적이다.
    - 집중 프로세스와 입출력 집중 프로세스가 동시에 자원을 요구했다고 가정하면, 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 입출력 집중 프로세스를 가능한 빨리 실행신 후 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적이다.
- 각각의 상황에 맞게 CPU를 배분하는 것이 효율적이다.
- 프로세스 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록하기 위해 **운영체제는 프로세스마다 우선순위를 부여합니다**.

## 스케줄링 큐
- PCB에 우선순위가 적혀있다곤 하지만 CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다.
- 그래서 운영체제 들은 프로세스 들에게 '줄을 서서 기다릴 것'을 요구한다.
- 그리고 운영체제는 이 줄을 스케줄링 큐로 구현하고 관리한다.
    - 운영체제가 관리하는 대부분의 자원은 큐로 관리 됨!
    - 대표적으로 **준비 큐**와 **대기 큐**가 있다.

## 준비큐와 대기큐
- 준비 큐 : CPU를 이용하고 싶은 프로세스들이 서는 줄
- 대기 큐 : 입출력장치를 이용하기 위해 대기 상태에 접어둔 프로세스들이 서는 줄
- 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그 중 우선순위가 높은 프로세스를 먼저 실행한다.

## 선점형과 비선점형 스케줄링
- 갑자기 다른 급한 프로세스가 CPU를 지금 당장 사용하길 원한다면
1. CPU의 자원을 빼앗아 다른 프로세스에 할당하거나 (선점형 스케줄링)
2. CPU를 사용중인 프로세스의 작업이 끝날 떄 까지 다른 프로세스를 기다리게 할 수 있음 (비 선점형 스케줄링)

### 선점형 스케줄링
- (+) 한 프로세스의 자원 독점을 막고, 프로세스들에 골고루 자원을 분배할 수 있다.
- (-) 문맥 교환 과정에서 오버헤드가 생길 수 있다.

### 비선점형 스케줄링
- (+) 문맥 교환횟수가 선점형 스케줄링 보다 적기 떄문에 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링 보다 적다
- (-) 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용할 수 없다. 

# CPU 스케줄링 알고리즘
1. 선입 선처리 스케줄링
2. 최단 작업 우선 스케줄링
3. 라운드 로빈 스케줄링
4. 최소 잔여 시간 우선 스케줄링
5. 우선순위 스케줄링
6. 다단계 큐 스케줄링
7. 다단계 피드백 큐 스케줄링

### 1. 선입 선처리 스케줄링
- 큐에 삽입된 순서대로 프로세스들을 처리하는 **비선점형 스케줄링 방식**
- 때때로 프로세스들이 기다리는 시간이 매우 길어 "호위 효과" 현상이 발생함

### 2. 최단 작업 우선 스케줄링
- CPU 사용 시간이 짧은 프로세스 부터 실행
- 기본적으론 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구형될 수도 있음

### 3. 라운드 로빈 스케줄링
- 선입 선 처리 스케줄링 + 타임 슬라이스
- "타임 슬라이스"란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다.
- 정해진 타임 슬라이스 만큼의 시간 동안 돌아가며 CPU를 이용할 수 있는 선점형 스케줄링 방식!!
- 타임 슬라이스의 크기가 매우 중요! 타임 슬라이스가 지나치게 작으면 문맥 교환에 발생하는 비용이 커짐

### 4. 최소 잔여 시간 우선 스케줄링
- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
- 최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 스라이스 만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 적은 프로세스가 선택된다.

### 5. 우선순위 스케줄링
- 우선순위가 높은 프로세스들에 의해 실행이 계속해서 연기될 수 있다. "기아 현상 발생"
- 이를 방지하기 위한 대표적인 기법은 "에이징"이 있다. 오랫동안 대기한 프로세스의 우선순위를 점차 높히는 방식

### 6. 다단계 큐 스케줄링
- 우선순위 스케줄링의 발전된 형태, 우선 순위별로 준비 큐를 여러개 사용하는 스케줄링 방식
- 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리한다.
- 큐를 여러개 두면 프로세스 유형 별로 우선 순위를 구분하여 실행하는 것이 편리해짐
- 단, 프로세스들이 큐 사이를 이동할 수 없다. -> 우선순위가 낮은 프로세스 들은 계속 연기 -> 기아현상 발생

### 7. 다단계 피드백 큐 스케줄링
- 다단계 큐 스케줄링의 발전된 형태 
- 프로세스들이 큐 사이를 이동 할 수 있습니다.
- 새로 준비된 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행된다.
- 만약 프로세스가 해당 큐에서 끝나지 않았다면 우선순위 큐에 삽입되어 실행됨 (반복)
- 결국 CPU를 오래 사용해야 하는 프로세스 들은 점차 우선순위가 낮아진다.
- (+) 프로세스 들이 큐 사이를 이동할 수 있는 방식이기 때문에 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위를 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방한다.
